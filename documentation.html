<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Mill</title>
  <style>
  body {font-family:sans-serif;} 
  #toplist {
    padding-left: 0px;
  }
  #toplist li {
    display: inline;
    list-style-type: none;
    padding-right: 15px;
  }
  a {color:#000000;}
  </style>
</head>
<body>
<div style="width:50em">

<h1>Mill - C language with coroutines</h1>

<b>
<ul id='toplist'>
<li><a href="index.html">Home</a></li>
<li><a href="download.html">Download</a></li>
<li><a href="documentation.html">Documentation</a></li>
<li><a href="development.html">Development</a></li>
<li><a href="community.html">Community</a></li>
</ul>
</b>

<h2>Documentation</h2>

<ul style="list-style: none;">
<li><a href="#ch1">Introduction to coroutines</a></li>
<li><a href="#ch2">Introduction to Mill</a></li>
<li><a href="#ch3">Usage</a></li>
<li><a href="#ch4">Defining a coroutine</a></li>
<li><a href="#ch5">Launching coroutines</a></li>
<li><a href="#ch6">Waiting for coroutines</a></li>
<li><a href="#ch7">Coroutine aliasing</a></li>
<li><a href="#ch8">Returning data from coroutines</a></li>
<li><a href="#ch9">Canceling coroutines</a></li>
<li><a href="#ch10">Comment on memory management</a></li>
<li><a href="#ch11">Including files</a></li>
<li><a href="#ch12">The standard library</a></li>
    <ul style="list-style: none;">
    <li><a href="#ch12.1">msleep</a></li>
    <li><a href="#ch12.2">getaddressinfo</a></li>
    <li><a href="#ch12.3">tcpsocket</a></li>
    </ul>
<li><a href="#ch13">Debugging</a></li>
</ul>

<a name="ch1"/><h3>Introduction to coroutines</h3>

<p>Coroutines are a way to implement cooperative multitasking in a rather simple
and developer-friendly manner. If you are not familiar with coroutines, check
the wikipedia article here:</p>

<p><a href="https://en.wikipedia.org/wiki/Coroutine">https://en.wikipedia.org/wiki/Coroutine</a></p>

<p>A nice explanation of how to implement coroutines in C can be found here:</p>

<p><a href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html</a></p>

<a name="ch2"/><h3>Introduction to Mill</h3>

<p>To use coroutines, it is best to choose a language that has direct support for
the concept, such as Go.</p>

<p>However, sometimes there is no other option but to use C. After all, C is
the lingua franca of programming languages and it works even where other
languages don't. Want to write code for an exotic embedded system? C will do
the job. Need to write a piece of kernel code? C saves the day. Want to
implement a shared library? C is here to help.</p>

<p>In C, coroutines can be written by hand (see the link above). However, once
you move beyond the very basic functionality all the required boilerplate code
is both annoying to write and confusing to read.</p>

<p>Mill tries to solve this problem by defining a slightly augmented version of
C language, one with direct support for coroutines.</p>

<p>Mill is more than a coroutine generator though. It tries to tame the
complexity inherent in asynchronous programming by defining additional
constrains on what can be done.

<p>For example, when coroutine ends, all the coroutines that it have launched
are automatically canceled. What it means is that there's a proper coroutine
encapsulation, similar to the one we are used to with standard C functions:
When coroutine exits, the caller is sure that there are no associated lefotver
threads of execution still running.<p>

<p>Another example: Sending messages between coroutines is reduced to the
bare minimum. Coroutine can send messages only to the coroutine that have
launched it and it can send it only a single "I am done" message. The message is
sent automatically when the coroutine completes its execution and thus the
user doesn't have to deal with messaging at all.</p>

<p>The hope is that such constrains won't affect expressivity of the language,
yet, they will make the code cleaner, simpler and easier to understand and
maintain.</p>

<a name="ch3"/><h3>Usage</h3>

<p>Mill is a preprocessor that generates raw C code from "augmented C" or
"C with coroutines". Following commands will generate <tt>foo.h</tt> from
<tt>foo.mh</tt> and <tt>foo.c</tt> from <tt>foo.mc</tt>:</p>

<pre>
    $ mill foo.mh
    $ mill foo.mc
</pre>

<p>The generated code is:</p>

<ul>
<li>Heavily commented</li>
<li>Properly indented</li>
<li>Not obfuscated (no macros or such)</li>
</ul>

<p>Therefore, it should be easy to read the code, understand it,
debug it and reason about it.</p>

<p>The generated code is compiled as standard C. The only additional
requirement is to link it with <tt>stdmill</tt> library:</p>

<pre>
    $ gcc -o foo foo.c -lstdmill
</pre>

<a name="ch4"/><h3>Defining a coroutine</h3>

<p>Use <tt>coroutine</tt> keyword to define a new coroutine. The syntax mimics
the syntax of standard C function, except that it has no return value:</p>

<pre>
    coroutine add (int a, int b, int *result)
    {
        *result = a + b;
    }
</pre>

<p>As with C functions, coroutines can be also declared to have only local
visibility:</p>

<pre>
    static coroutine foo ();
</pre>

<t>Coroutines implement cooperative multitasking and thus single blocked
coroutine can block all the other coroutines. Therefore, make sure that
no blocking calls, such as <tt>sleep()</tt> or <tt>recv()</tt> are used inside
of the coroutine.</t>

<p>Mill is a simple preprocessor that doesn't do full semantic analysis of the
source. The price for such simplicity is that it is not able to automatically
distinguish variable declarations from the other stuff in the codebase. To help
the parser, you must locate all the local variable declarations at the top
of the coroutine. The declarations must be followed by <tt>endvars</tt>
keyword:</p>

<pre>
    coroutine foo ()
    {
        int i = 0;
        endvars;

        i = i + 1;
    }
</pre>

<p>WARNING: If you put local variable declarations elsewhere, Mill won't
complain about the fact but the behaviour of the coroutine will become
undefined. Expect values of such variables to change randomly while coroutine is
in progress.</p>

<a name="ch5"/><h3>Launching coroutines</h3>

<p>Use <tt>go</tt> keyword to launch a coroutine. The new coroutine will run
in parallel with its parent coroutine:</p>

<pre>
    coroutine foo ()
    {
        printf ("Hello, world!\n");
    }

    coroutine bar ()
    {
        go foo();
    }
</pre>

<p>Please note that coroutines can be launched in this way only from other
coroutines. Trying to launch a coroutine this way from standard C funcion will
result in a syntax error.</t>

<p>If you want to launch a coroutine from a plain old C function you have to run
it in synchornous manner:</p>

<pre>
    coroutine foo ()
    {
        printf ("Hello, world!\n");
    }

    int main ()
    {
        foo ();
        return 0;
    }
</pre>

<p>In this case the coroutine won't execute in parallel with the parent 
function. Instead, the function will block until the coroutine is
finished.</p>

<t>Given the blocking behaviour, couroutines should not be invoked like this
from outher coroutines.</t>

<a name="ch6"/><h3>Waiting for coroutines</h3>

<p>Use <tt>select</tt> keyword to wait for termination of child coroutine:</p>

<pre>
    coroutine bar ()
    {
        go foo ();

        select {
        case foo:
            printf ("foo is done!\n");
        }
    }
</pre>

<p>The construct is waiting for a specific type of coroutine (<tt>foo</tt> in
this case) rather than for termination of specific coroutine invocation. Thus,
in the following example <tt>select</tt> waits for termination of any of the
child coroutines:</p>

<pre>
    coroutine bar ()
    {
        go foo ();
        go foo ();
        go foo ();

        while (1) {
            select {
            case foo:
                printf ("foo is done!\n");
            }
        }
    }
</pre>

<p>Note that unlike with <tt>switch</tt> statement, there's no fall-through
between individual clauses of the <tt>select</tt> statement. It's always
exactly one clause that's executed:</p>

<pre>
    coroutine foo ()
    {
        go bar ();

        select {
        case bar:
            printf ("bar is done!\n");
        case baz:
            printf ("this line is never executed!\n");
        }
    }
</pre>

<p>What is also means is that <tt>break</tt> statement within <tt>select</tt>
construct doesn't break out of the <tt>select</tt> but rather from the next
closest <tt>for</tt> or <tt>while</tt> loop.</p>

<a name="ch7"/><h3>Coroutine aliasing</h3>

<t>So what if you want to distinguish between different instances of
<tt>foo</tt> coroutine?</t>

<p>Mill provides a convenience construct for that kind of thing. It's called
coroutine aliasing:</p>

<pre>
    coroutine bar = foo;
</pre>

<p>Aliased coroutine <tt>bar</tt> behaves exactly like the original coroutine
<tt>foo</tt> but it is treated as a different coroutine by the <tt>select</tt>
statement:</p>

<pre>
    coroutine bar = foo;
    coroutine baz = foo;

    coroutine quux ()
    {
        go bar ();
        go baz ();

        while (1) {
            select {
            case bar:
                printf ("coroutine bar done!\n");
            case baz:
                printf ("coroutine baz done!\n");
            }
        }
    }
</pre>

<a name="ch8"/><h3>Returning data from coroutines</h3>

<p>Coroutines have no return values. However, you can use standard output
parameters and they should work as expected:</p>

<pre>
    coroutine foo (int *result)
    {
        *result = 1;
    }

    coroutine bar ()
    {
        int i;
        endvars;

        go foo (&i);

        select {
        case foo:
            assert (i == 1);
        }
    }
</pre>

<p>There's a problem though if multiple coroutines write the result into a
single location. The result from one instance of the coroutine can
be overwritten by a result from another instance:</p>

<pre>
    coroutine foo (int *result, int i)
    {
        *result = i;
    }

    coroutine bar ()
    {
        int i;
        endvars;

        go foo (&i, 1);
        go foo (&i, 2);

        select {

        // This clause may be invoked because foo(1) have ended, thus i == 1.
        case foo: 

            // foo(2) ends here and stores value 2 into i.
            assert (i == 1); // Assert fails.
        }
    }
</pre>

<p>To address this problem <tt>out</tt> keyword is introduced. The coroutine
argument marked with <tt>out</tt> is allocated at callee's coframe (like a stack
frame, but for coroutines) and copied to the caller-specified destination
only when the coroutine is selected:</p>

<pre>
    coroutine foo (out int *result, int i)
    {
        *result = i;
    }

    coroutine bar ()
    {
        go foo (&i, 1);
        go foo (&i, 2);
        go foo (&i, 3);

        while (1) {
            select {
            case foo:
                printf ("coroutine foo returned %d\n", i);
            }
        }
    }
</pre>

<a name="ch9"/><h3>Canceling coroutines</h3>

<p>One of the main principles in mill is that lifetime of a coroutine never
exceeds the lifetime of the coroutine that have launched it.</p>

<p>Therefore, if child coroutine is still being executed when the parent
coroutine is terminating, the former is automatically canceled. There's no need
for any explicit action on parent's behalf.</p>

<p>However, the child coroutine may want to intercept the cancellation and do
any necessary cleanup.</p>

<p>Given that coroutines can be interrupted only while waiting inside a select
statement, the interception can be done by simply adding a <tt>cancel</tt>
clause to the statement:</p>

<pre>
    coroutine foo (out char *result)
    {
        result = malloc (14);
        memcpy (result, "Hello, world!", 14);

        go msleep (1000);

        select {
        case msleep:
            return;
        cancel:
            free (result);
            return;
        }
    }
</pre>

</p>If <tt>cancel</tt> clause is not specified the coroutine is canceled
straight away without executing any user-defined code.</p>

<p>There's one more cancelation scenario: The child coroutine may have been
fully executed, yet the parent coroutine may exit without selecting it. In such
case the coroutine being canceled (the child coroutine) still needs to do
cleaned up, specifically, it needs to deallocate any dynamically allocated
output parameters.</p>

<p>It can be done by adding the <tt>cancel</tt> clause to the coroutine
itself:</p>

<pre>
    coroutine foo (out char *result)
    {
        result = malloc (14);
        memcpy (result, "Hello, world!", 14);
    cancel:
        free (result);
    }
</pre>

<p>The <tt>cancel</tt> construct is somewhat confusing in that it has a distinct
exception-handling feel about it. However, the feeling is misleading.</p>

<p>Where the likes of <tt>catch</tt> construct handle errors in the child
functions, Mill's <tt>cancel</tt> construct handles cancellation events in 
the parent coroutines.</p>

<p>In other words, while exception handling bubbles the errors up the stack
(from callees to callers) Mill's cancellation mechanism propagates the cancel
requests down the stack (from callers to callees).</p>

<a name="ch10"/><h3>Comment on memory management</h3>

<p>Keep in mind that coframes are deallocated when the child coroutine is
selected. If you launch a coroutine without selecting it afterwards, the
coframe will linger on in the memory until it is deallocated when the
caller coroutine terminates.</p>

<p>The behaviour is perfectly all right in most circumstances, however,
launching arbitrary number of coroutines in a loop without selecting them can
lead to memory exhaustion:</p>

<pre>
    coroutine foo ()
    {
        /* Don't do this at home! */
        while (1) {
            go msleep (1000);
        }
    }
</pre>

<a name="ch11"/><h3>Including files</h3>

<p>Mill source files can include other Mill files directly like this:</p>

<pre>
    #include "foo.mh"
    #include &lt;bar.mh&gt;
</pre>

<p>Keep in mind, however, that raw C code cannot include Mill files. C, after
all, knows nothing about Mill and trying to compile Mill code using standard
C compiler would result in syntax errors.</p>

<p>What you have to do is to include the generated C files instead:</p>

<pre>
    #include "foo.h"
    #include &lt;bar.h&gt;
</pre>

<a name="ch12"/><h3>The standard library</h3>

</p>Standard library (<tt>stdmill</tt>) contains atomic coroutines that can be
used to construct more complex programs.</p>

<p>Declarations of standard library functions are in <tt>stdmill.h</tt> header
file:</p>

<pre>
    #include &lt;stdmill.h&gt;
</pre>

The implementations are in <tt>stdmill</tt> shared library.</p>

<a name="ch12.1"/><h4>msleep</h4>

<pre>
    coroutine msleep (
        int milliseconds);
</pre>

<p>Sleep for specified amount of milliseconds.</p>

<p>Given that the above is a coroutine (and thus executes asynchronously) it
can be thought of as an alarm and used for implementing timeouts.</p>

<p>Example:</p>

<pre>
    coroutine foo ()
    {
        go bar ();
        go msleep (1000);
        select {
        case bar:
            printf ("bar was successfully executed!\n");
        case msleep:
            printf ("bar have timed out!\n");
        }
    }
</pre>

<a name="ch12.2"/><h4>getaddressinfo</h4>

<pre>
    coroutine getaddressinfo (
        out int *rc,
        const char *node,
        const char *service,
        const struct addrinfo *hints,
        out struct addrinfo **res);

    void freeaddressinfo (
        struct addrinfo *ai);
</pre>

<p>Translate network address, similar to POSIX <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/getaddrinfo.html"><tt>getaddrinfo</tt></a> function. Check POSIX documentation
for argument details.</p>

<p>Use <tt>freeaddressinfo</tt> function to deallocate the result.</p>

<p>Example:</p>

<pre>
    coroutine foo ()
    {
        int rc;
        struct addrinfo *info;
        endvars;

        go getaddressinfo (&rc, "example.org", NULL, NULL, &info);
        select {
        case getaddressinfo:
            assert (rc == 0);
        }

        /* Do stuff here. */

        freeaddressinfo (info);
    }
</pre>

<a name="ch12.3"/><h4>tcpsocket</h4>

<pre>
    struct tcpsocket;

    int tcpsocket_init (
	    struct tcpsocket *self);

    coroutine tcpsocket_term (
	    struct tcpsocket *self);

    int tcpsocket_bind (
	    struct tcpsocket *self,
	    struct sockaddr *addr,
	    int flags);

    int tcpsocket_listen (
	    struct tcpsocket *self,
	    int backlog);

    coroutine tcpsocket_connect (
	    out int *rc,
	    struct tcpsocket *self,
	    struct sockaddr *addr);

    coroutine tcpsocket_accept (
	    out int *rc,
	    struct tcpsocket *self,
	    struct tcpsocket *newsock);

    coroutine tcpsocket_send (
	    out int *rc,
	    struct tcpsocket *self,
	    const void *buf,
	    size_t len);

    coroutine tcpsocket_recv (
	    out int *rc,
	    struct tcpsocket *self,
	    void *buf,
	    size_t len);
</pre>

<a name="ch13"/><h3>Debugging</h3>

<p>To make debugging of the asynchronous system easier, mill has support for
tracing. You can switch it on by invoking <tt>_mill_trace()</tt> function.</p>

<p>The tracing output goes into <tt>stderr</tt> and looks like this:</p>

<pre>
    mill ==> go     test
    mill ==> go     test/fx1
    mill ==> go     test/fx1/msleep
    mill ==> go     test/fx2
    mill ==> go     test/fx2/msleep
    mill ==> return test/fx1/msleep
    mill ==> select test/fx1/msleep
    mill ==> cancel test/fx2
    mill ==> cancel test/fx2/msleep
    mill ==> return test/fx2/msleep
    mill ==> return test/fx2
    mill ==> return test
</pre>

<p>Each line contains an operation and the coroutine's backtrace. So, for
example:</p>

<pre>
    mill ==> return test/fx2
</pre>

<p>Means that coroutine <tt>fx2</tt> invoked from top-level coroutine
<tt>test</tt> have finished execution.</p>

</div>
</body>
</html>
