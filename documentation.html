<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>mill</title>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>

<img src="mill.png"/>

<p><b>Go-style concurrency in C</b></p>

<ul id='toplist'>
<li><a href="index.html">Home</a></li>
<li><a href="download.html">Download</a></li>
<li><a href="documentation.html">Documentation</a></li>
<li><a href="development.html">Development</a></li>
<li><a href="community.html">Community</a></li>
</ul>

<h2>Documentation</h2>

<ul id="toc">
  <li><a href="#build">Build</a></li>
  <li><a href="#coroutines">Coroutines</a></li>
  <li><a href="#channels">Channels</a></li>
  <li><a href="#choose">Choose statement</a></li>
  <li><a href="#cls">Coroutine-local storage</a></li>
  <li><a href="#tcp">TCP library</a></li>
</ul>

<h3 id="build">Build</h3>

<p>Mill runs with x86_64, gcc and Linux/OSX.</p>

<p>Whether it works in different environments is not known - please, do report
any successes or failures on the project mailing list.</p>

<t>Build and install Mill as follows:</p>

<pre>
$ ./autogen.sh
$ ./configure
$ make
$ make check
$ sudo make install
</pre>

<p>After the installation there's <tt>mill.h</tt> available as well
as dynamic library <tt>libmill.so</tt> and static library
<tt>libmill.a</tt>.</p>

<p>A program using the library can look for example like this:</p>

<pre>
#include &lt;stdio.h&gt;
#include "mill.h"

void worker(int count, const char *text) {
    int i;
    for(i = 0; i != count; ++i) {
        printf("%s\n", text);
        msleep(10);
    }
}

int main() {
    go(worker(4, "a"));
    go(worker(2, "b"));
    go(worker(3, "c"));
    msleep(100);
    return 0;
}
</pre>

<p>To build the example:</p>

<pre>
gcc -o example example.c -lmill
</pre>

<h3 id="coroutines">Coroutines</h3>

<p>Any function can be executed as a coroutine using <tt>go</tt> keyword:</p>

<pre>
void foo(int i, int j) {
    ...
}

int main() {
    go(foo(1, 2));
    return 0;
}
</pre>

<p>Even functions with exotic argument lists can be executed as coroutines:</p>

<pre>
go(printf("%d + %d = %d\n", 2, 2, 4));
</pre>

<p>However, keep in mind that coroutines are executed asynchronously and thus,
even if the function returns a value, there is now way to retrieve it.</p>

<p>Also keep in mind that coroutines are scheduled in a cooperative fashion.
If one coroutine block, for example by calling <tt>sleep()</tt>, it blocks
the whole process. Therefore, coroutine-friendly versions of blocking functions
(such as <tt>mconnect()</tt> or <tt>msend()</tt>, see below) should be used.</p>

<p>In addition, you can yield CPU to other coroutines explicitly:</p>

<pre>
yield();
</pre>

<p>To sleep without blocking the entire process:</p>

<pre>
void msleep(unsigned long ms);
</pre>

<p>To wait for an event from a file descriptor use <tt>fdwait</tt> function:</p>

<pre>
int events = fdwait(FDW_IN | FDW_OUT);
if(events & FDW_IN) {
    ...
}
if(events & FDW_OUT) {
    ...
}
if(events & FDW_ERR) {
    ...
}
</pre>

<h3 id="channels">Channels</h3>

Channels are typed pipes used for communication between coroutines. To create
a channel you have to specify what kind of values are meant to be passed
through it. The second parameter is the buffer size. Setting this argument
to zero yields unbuffered channel:</p>

<pre>
chan ch = chmake(int, 0);
</pre>

<p>To send a value to the channel use <tt>chs</tt> construct. Note that
this is a statement, not a function returning a value. The type specified
as the second parameter must match the type of the channel otherwise you'll
get runtime exception.</p>

<pre>
chs(ch, int, 42);
</pre>

<p>To receive a value from the channel use <tt>chr</tt> expression. The type
specified as the second parameter must match the type of the channel otherwise
you'll get runtime exception.</p>

<pre>
int i = chr(ch, int);
</pre>

<p>When you are done with sending you can announce it using <tt>chdone</tt>
function. It will cause all the receivers on the channel to receive the
specified value indefinitely.</p>

<pre>
chdone(ch, int, -1);
</pre>

<p>To deallocate the channel use <tt>chclose</tt> function:</p>

<pre>
chclose(ch);
</pre>

<p>When sharing a channel between two or more coroutines you can duplicate
the channel handle. Channel is deallocated only after all its handles
are closed. For example:</p>

<pre>
void sender(chan ch) {
    chs(ch, int, 42);
    chclose(ch);
}

int main() {
    chan ch = chmake(int, 0);
    go(sender(chdup(ch)));
    int i = chr(ch, int);
    assert(i == 42);
    chclose(ch);
    return 0;
}
</pre>

<h3 id="choose">Choose statement</h3>

<p>Choose statement is equivalent to Go's <tt>select</tt> statement. It can be
used for waiting to send or receive data from multiple channels.</p>

<p>Within <tt>choose</tt> there's a list of clauses containing multiple
<tt>in</tt> and <tt>out</tt> statements and at most one <tt>otherwise</tt>
statement. Don't forget to add <tt>end</tt> statement before the closing
parenthesis.</p>

<p>Clause <tt>in</tt> causes <tt>choose</tt> to wait for a message coming
from channel <tt>ch</tt>. The clause declares variable <tt>var</tt> of type
<tt>type</tt> and stores the incoming message into it. If <tt>type</tt> doesn't
match the actual type of the channel you'll get a runtime exception.</p>

<pre>
in(ch, type, var):
</pre>

<p>Clause <tt>out</tt> causes <tt>choose</tt> to wait while value <tt>val</tt>
of type <tt>type</tt> can be sent to channel <tt>ch</tt>. Same way as with
</tt>in</tt>, if <tt>type</tt> doesn't match the actual type of channel
<tt>ch</tt> runtime exception is generated.</p>

<pre>
out(ch, type, val):
</pre>

<p>Clause <tt>otherwise</tt> is optional. It is executed only if no other
clauses can be matched immediately. Therefore, <tt>choose</tt> statement
with <tt>otherwise</tt> clause will never block.</p>

<pre>
choose {
in(ch1, int, val):
    printf("Value %d received from ch1.\n", val);
out(ch2, int, 42):
    printf("Value 42 sent to ch2.\n");
otherwise:
    printf("Neither ch1 nor ch2 can be used at the moment.\n");
end
}
</pre>

<p><tt>choose</tt> statement waits for the first available clause and executes
the code that follows it. If there are multiple clauses available
one of them is chosen at random.</p>

<p>There's no fall-through among the clauses.</p>

<h3 id="cls">Coroutine-local storage</h3>

<p>User can allocate coroutine-local data and attach it to the coroutine
using <tt>setcls</tt> function. For example:</p>

<pre>
struct mycls {
    int a;
    int b;
};

void *data = malloc(sizeof(struct mycls));
setcls(data);
</pre>

<p>Later on the data can be accessed anywhere within the coroutine using
<tt>cls</tt> function:</p>

<pre>
struct mycls *data = cls();
printf("CLS: a=%d b=%d\n", data->a, data->b);
</pre>

<p>It can be safely assumed that before coroutine-local data are set,
<tt>cls</tt> function will return <tt>NULL</tt>.</p>

<h3 id="tcp">TCP library</h3>

<p>TCP can be accessed via standard POSIX functions. However, Mill provides
a simple convenience wrapper for the functionality. To use it, add
<tt>tcp.h</tt> and <tt>tcp.c</tt> to your project.</p>

<p>To connect to a remote server, use <tt>tcpconnect</tt> function:

<pre>
struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_addr.s_addr = htonl(0x7f000001);
addr.sin_port = htons(5555);
tcpconn conn = tcpconnect((struct sockaddr*)&addr, sizeof(addr));
</pre>

<p>To start listening for incoming TCP connections use <tt>tcplisten</tt>
function. To accept next connection use <tt>tcpaccept</tt>function:</p>

<pre>
struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_addr.s_addr = INADDR_ANY;
addr.sin_port = htons(5555);
tcplistener listener = tcplisten((struct sockaddr*)&addr, sizeof(addr));
while(1) {
    tcpconn conn = tcpaccept(listener);
    ...
}
</pre>

<p>To send data to the connection use <tt>tcpwrite</tt> function:</p>

<pre>
tcpwrite(conn, "ABC", 3);
</pre>

<p>To optimise the throughput <tt>tcpwrite</tt> may store the data into output
buffer and not flush it into the network immediately. To force actual sending
of the data use <tt>tcpflush</tt> function.</p>

</p>The function returns 0 in case of success and -1 in case of error:</p>

<pre>
int rc = tcpflush(conn);
assert(rc == 0);
</pre>

<p>To read data from a connection use <tt>tcpread</tt> function:</p>

<pre>
char buf[3];
ssize_t res = tcpread(conn, buf, sizeof(buf));
</pre>

</p>The function returns 0 in case of success and -1 in case of error.</p>

<p><tt>tcpreaduntil</tt> function is the same as <tt>tcpread</tt> except
that the reading stops when a specific character is encountered:</p>

<pre>
char buf[256];
ssize_t res = tcpreaduntil(conn, buf, sizeof(buf), '\n');
</pre>

</p>If function managed to fill the entire buffer it returns 0. If the delimiter
character was encountered in the process return value is total amount of
characters read including the delimiter character. In case of error the function
returns -1.</p>

<p>To close the connection use <tt>tcpconn_close</tt> function:</p>

<pre>
tcpconn_close(conn);
</pre>

<p>To close the listener use <tt>tcplistener_close</tt> function:</p>

<pre>
tcplistener_close(listener);
</pre>

</body>
</html>

