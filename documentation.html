<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Mill</title>
  <style>
  body {font-family:sans-serif;} 
  #toplist {
    padding-left: 0px;
  }
  #toplist li {
    display: inline;
    list-style-type: none;
    padding-right: 15px;
  }
  a {color:#000000;}
  </style>
</head>
<body>
<div style="width:50em">

<h1>Mill - C language with coroutines</h1>

<b>
<ul id='toplist'>
<li><a href="index.html">Home</a></li>
<li><a href="download.html">Download</a></li>
<li><a href="documentation.html">Documentation</a></li>
<li><a href="development.html">Development</a></li>
<li><a href="community.html">Community</a></li>
</ul>
</b>

<h2>Documentation</h2>

<h3>Introduction to coroutines</h3>

<p>Coroutines are a way to implement cooperative multitasking in a rather simple
and developer-friendly manner.</p>

<p>If you are not familiar with coroutines, check the wikipedia article here:</p>

<p><a href="https://en.wikipedia.org/wiki/Coroutine">https://en.wikipedia.org/wiki/Coroutine</a></p>

<p>A nice explanation of how to implement coroutines in C can be found here:</p>

<p><a href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html</a></p>

<h3>Mill</h3>

<p>To use coroutines, it is best to choose a language that has direct support for
the concept, such as Go.</p>

<p>However, sometimes there is no other option but to use C. After all, C is
the lingua franca of programming languages and it works even where other
languages don't. Want to write code for an exotic embedded system? C will do
the job. Need to write a piece of kernel code? C saves the day. Want to
implement a shared library? C is here to help.</p>

<p>In C, coroutines can be written by hand (see the link above). However, once
you move beyond the very basic functionality all the required boilerplate code
is both annoying to write and confusing to read.</p>

<p>Mill tries to solve this problem by defining a slightly augmented version of
C language, one with direct support for coroutines.</p>

<p>Mill is more than a coroutine generator though. It tries to tame the
complexity inherent in asynchronous programming by defining additional
constrains on what can be done.

<p>For example, when coroutine ends, all the coroutines that it have launched
are automatically canceled. What it means is that there's a proper coroutine
encapsulation, similar to the one we are used to with standard C functions:
When coroutine exits, the caller is sure that there are no lefotver threads of
execution still running.<p>

<p>Another example: Sending of messages between coroutines is reduced to the
bare minimum. Coroutine can send messages only to the coroutine that have
launched it and it can send it only a single "I am done" message. The message is
sent automatically when the coroutine completes its execution and thus the
user doesn't have to deal with messaging at all.</p>

<p>The hope is that such constrains won't affect expressivity of the language,
yet, they will make the code cleaner, simpler and easier to understand and
maintain.</p>

<h3>Usage</h3>

<p>Following commands will generate <tt>foo.h</tt> from <tt>foo.mh</tt> and
<tt>foo.c</tt> from <tt>foo.mc</tt>:</p>

<pre>
    $ mill foo.mh
    $ mill foo.mc
</pre>

<h3>Defining a coroutine</h3>

<p>Use <tt>coroutine</tt> keyword to define a new coroutine. The syntax mimics
the syntax of standard C function, except that it has no return value:</p>

<pre>
    coroutine add (int a, int b, int *result)
    {
        *result = a + b;
    }
</pre>

<t>Coroutines implement cooperative multitasking and thus single blocked
coroutine can block all the other coroutines. Therefore, make sure that
no blocking calls, such as <tt>sleep()</tt> or <tt>recv()</tt> are used inside
of the coroutine.</t>

<p>Mill is a simple preprocessor that doesn't do full semantic analysis of the
source. The price for such simplicity is that it is not able to automatically
distinguish variable declarations from the other stuff in the codebase. To help
the parser, you must locate all the local variable declarations at the top
of the coroutine. The declarations must be followed by <tt>endvars</tt>
keyword:</p>

<pre>
    coroutine foo ()
    {
        int i = 0;
        endvars;

        i = i + 1;
    }
</pre>

<p>WARNING: If you put local variable declarations elsewhere, Mill won't
complain about the fact but the behaviour of the coroutine will become
undefined. Expect values of such variables to change randomly while coroutine is
in progress.</p>

<h3>Launching coroutines</h3>

<p>Use <tt>go</tt> keyword to launch a coroutine. The new coroutine will run
in parallel with its parent coroutine:</p>

<pre>
    coroutine foo ()
    {
        printf ("Hello, world!\n");
    }

    coroutine bar ()
    {
        go foo();
    }
</pre>

<p>Please note that coroutines can be launched in this way only from other
coroutines. Trying to launch a coroutine this way from standard C funcion will
result in a syntax error.</t>

<p>If you want to launch a coroutine from a plain old C function you have to run
it in synchornous manner:</p>

<pre>
    coroutine foo ()
    {
        printf ("Hello, world!\n");
    }

    int main ()
    {
        foo ();
        return 0;
    }
</pre>

<p>In this case the coroutine won't execute in parallel with the parent 
function. Instead, the function will be blocked until the coroutine is
finished.</p>

<t>Given the blocking behaviour, couroutines should not be invoked like this
from outher coroutines.</t>

<h3>Waiting for coroutines</h3>

<p>Use <tt>select</tt> keyword to wait for termination of child coroutine:</p>

<pre>
    coroutine bar ()
    {
        go foo ();

        select {
        case foo:
            printf ("foo is done!\n");
        }
    }
</pre>

<p>The construct is waiting for a specific type of coroutine (<tt>foo</tt> in
this case) rather than for termination of specific coroutine invocation. Thus,
in the following example <tt>select</tt> waits for termination of any of the
child coroutines:</p>

<pre>
    coroutine bar ()
    {
        go foo ();
        go foo ();
        go foo ();

        while (1) {
            select {
            case foo:
                printf ("foo is done!\n");
            }
        }
    }
</pre>

<p>Note that unlike with <tt>switch</tt> statement, there's no fall-through
between individual clauses of the <tt>select</tt> statement. It's always
exactly one clause that's executed:</p>

<pre>
    coroutine foo ()
    {
        go bar ();

        select {
        case bar:
            printf ("bar is done!\n");
        case baz:
            printf ("this line is never executed!\n");
        }
    }
</pre>

<p>What is also means is that <tt>break</tt> statement within <tt>select</tt>
construct doesn't break out of the <tt>select</tt> but rather from the next
closest <tt>for</tt> or <tt>while</tt> loop.</p>

<h3>Coroutine aliasing</h3>

<t>So what if you want to distinguish between different instances of
<tt>foo</tt> coroutine?</t>

<p>Mill provides a convenience construct for that kind of thing. It's called
coroutine aliasing:</p>

<pre>
    coroutine bar = foo;
</pre>

<p>Aliased coroutine <tt>bar</tt> behaves exactly like the original coroutine
<tt>foo</tt> but it is treated as a different coroutine by the <tt>select</tt>
statement:</p>

<pre>
    coroutine bar = foo;
    coroutine baz = foo;

    coroutine quux ()
    {
        go bar ();
        go baz ();

        while (1) {
            select {
            case bar:
                printf ("coroutine bar done!\n");
            case baz:
                printf ("coroutine baz done!\n");
            }
        }
    }
</pre>

<h3>Returning data from coroutines</h3>

<p>Coroutines have no return values. However, you can use standard output
parameters and they should work as expected:</p>

<pre>
    coroutine foo (int *result)
    {
        *result = 1;
    }

    coroutine bar ()
    {
        int i;
        endvars;

        go foo (&i);

        select {
        case foo:
            assert (i == 1);
        }
    }
</pre>

<p>There's a problem though if multiple coroutines write the result into a
single location. The result from one instance of the coroutine can
be overwritten by a result from another instance:</p>

<pre>
    coroutine foo (int *result, int i)
    {
        *result = i;
    }

    coroutine bar ()
    {
        int i;
        endvars;

        go foo (&i, 1);
        go foo (&i, 2);

        select {

        // This clause may be invoked because foo(1) have ended, thus i == 1.
        case foo: 

            // foo(2) ends here and stores value 2 into i.
            assert (i == 1); // Assert fails.
        }
    }
</pre>

<p>To address this problem <tt>out</tt> keyword is introduced. The coroutine
argument marked with <tt>out</tt> is allocated at callee's coframe (like a stack
frame, but for coroutines) and copied to the caller-specified destination
only when the coroutine is selected:</p>

<pre>
    coroutine foo (out int *result, int i)
    {
        *result = i;
    }

    coroutine bar ()
    {
        go foo (&i, 1);
        go foo (&i, 2);
        go foo (&i, 3);

        while (1) {
            select {
            case foo:
                printf ("coroutine foo returned %d\n", i);
            }
        }
    }
</pre>

<h3>Canceling coroutines</h3>

<p>One of the main principles in mill is that lifetime of a coroutine never
exceeds the lifetime of the coroutine that have launched it.</p>

<p>Therefore, if child coroutine is still being executed when the parent
coroutine is terminating, the former is automatically canceled. There's no need
for any explicit action on parent's behalf.</p>

<p>However, the child coroutine may want to intercept the cancellation and do
any necessary cleanup.</p>

<p>Given that coroutines can be interrupted only while waiting inside a select
statement, the interception can be done by simply adding a <tt>cancel</tt>
clause to the statement:</p>

<pre>
    coroutine foo (out char *result)
    {
        result = malloc (14);
        memcpy (result, "Hello, world!", 14);

        go msleep (1000);

        select {
        case msleep:
            return;
        cancel:
            free (result);
            return;
        }
    }
</pre>

<p>There's one more cancelation scenario: The child coroutine may have been
fully executed, yet the parent coroutine may exit without selecting it. In such
case the coroutine being canceled (the child coroutine) still needs to do
cleaned up, specifically, it needs to deallocate any dynamically allocated
output parameters.</p>

<p>It can be done by adding the <tt>cancel</tt> clause to the coroutine
itself:</p>

<pre>
    coroutine foo (out char *result)
    {
        result = malloc (14);
        memcpy (result, "Hello, world!", 14);
    cancel:
        free (result);
    }
</pre>

<p>The <tt>cancel</tt> construct is somewhat confusing in that it has a distinct
exception-handling feel about it. However, the feeling is misleading.</p>

<p>Where the likes of <tt>catch</tt> construct handle errors in the child
functions, Mill's <tt>cancel</tt> construct handles cancellation events in 
the parent coroutines.</p>

<p>In other words, while exception handling bubbles the errors up the stack
(from callees to callers) Mill's cancellation mechanism propagates the cancel
requests down the stack (from callers to callees).</p>

<h3>Comment on memory management</h3>

<p>Keep in mind that coframes are deallocated when the child coroutine is
selected. If you launch a coroutine without selecting it afterwards, the
coframe will linger on in the memory until it is deallocated when the
caller coroutine terminates.</p>

<p>The behaviour is perfectly all right in most circumstances, however,
launching arbitrary number of coroutines in a loop without selecting them can
lead to memory exhaustion:</p>

<pre>
    coroutine foo ()
    {
        /* Don't do this at home! */
        while (1) {
            go msleep (1000);
        }
    }
</pre>

<h3>Debugging</h3>

<p>To make debugging of the asynchronous system easier, mill has support for
tracing. You can switch it on by invoking <tt>_mill_trace()</tt> function.</p>

<p>The tracing output looks like this:</p>

<pre>
    mill ==> go     test
    mill ==> go     test/fx1
    mill ==> go     test/fx1/msleep
    mill ==> go     test/fx2
    mill ==> go     test/fx2/msleep
    mill ==> return test/fx1/msleep
    mill ==> select test/fx1/msleep
    mill ==> cancel test/fx2
    mill ==> cancel test/fx2/msleep
    mill ==> return test/fx2/msleep
    mill ==> return test/fx2
    mill ==> return test
</pre>

<p>Each line contains an operation and the coroutine's backtrace. So, for
example:</p>

<pre>
    mill ==> return test/fx2
</pre>

<p>Means that coroutine <tt>fx2</tt> invoked from top-level coroutine
<tt>test</tt> have finished execution.</p>

<h3>Avoiding the dependency on libstdmill.so</h3>

<p>If you want your users not to have to install Mill runtime library, you
can simply add the source files (<tt>stdmill.h</tt> and <tt>stdmill.c</tt>)
directly to your project.<p>

<p>However, keep in mind that in such case you should set your compiler's
include path in such a way that it points to the location of <tt>stdmill.h</tt>
file.</p>

<p>Also consider that although the above will remove dependency on
<tt>libstdmill.so</tt> you will still need to have <tt>libuv.so</tt>
installed.</p>

</div>
</body>
</html>
