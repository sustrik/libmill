<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>libmill</title>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>

<img src="libmill.png"/>

<p><b>Go-style concurrency in C</b></p>

<ul id='toplist'>
<li><a href="index.html">Home</a></li>
<li><a href="download.html">Download</a></li>
<li><a href="documentation.html">Documentation</a></li>
<li><a href="development.html">Development</a></li>
<li><a href="community.html">Community</a></li>
</ul>

<h2>Documentation</h2>

<ul id="toc">
  <li><a href="#build">Build</a></li>
  <li><a href="#coroutines">Coroutines</a></li>
  <li><a href="#channels">Channels</a></li>
  <li><a href="#choose">Choose statement</a></li>
  <li><a href="#cls">Coroutine-local storage</a></li>
  <li><a href="#tcp">TCP library</a></li>
  <li><a href="#debug">Debugging</a></li>
</ul>

<h3 id="build">Build</h3>

<p>Libmill runs with x86_64, gcc and Linux/OSX.</p>

<p>Whether it works in different environments is not known - please, do report
any successes or failures on the project mailing list.</p>

<t>Download the package from the download page. Then build and install
as follows:</p>

<pre>
$ tar -xzf libmill-0.7-beta.tar.gz
$ cd libmill-0.7-beta
$ ./configure
$ make
$ make check
$ sudo make install
</pre>

<p>After the installation there's <tt>libmill.h</tt> header file available
as well as dynamic library <tt>libmill.so</tt> and static library
<tt>libmill.a</tt>.</p>

<p>A program using the library can look for example like this:</p>

<pre>
#include &lt;stdio.h&gt;
#include "libmill.h"

void worker(int count, const char *text) {
    int i;
    for(i = 0; i != count; ++i) {
        printf("%s\n", text);
        msleep(10);
    }
}

int main() {
    go(worker(4, "a"));
    go(worker(2, "b"));
    go(worker(3, "c"));
    msleep(100);
    return 0;
}
</pre>

<p>To build the example:</p>

<pre>
gcc -o example example.c -lmill
</pre>

<h3 id="coroutines">Coroutines</h3>

<p>Any function can be executed as a coroutine using <tt>go</tt> keyword:</p>

<pre>
void foo(int i, int j) {
    ...
}

int main() {
    go(foo(1, 2));
    return 0;
}
</pre>

<p>However, keep in mind that coroutines are executed asynchronously and thus,
even if the function returns a value, there is now way to retrieve it.</p>

<p>Also bear in mind that coroutines are scheduled in a cooperative fashion.
If one coroutine blocks, for example by calling <tt>sleep()</tt>, it blocks
the entire process. Therefore, coroutine-friendly versions of blocking functions
(such as <tt>msleep()</tt> or <tt>fdwait()</tt>, see below) should be used.</p>

<p>In addition, you can yield CPU to other coroutines explicitly:</p>

<pre>
yield();
</pre>

<p>To sleep without blocking the entire process:</p>

<pre>
void msleep(unsigned long ms);
</pre>

<p>To wait for an event from a file descriptor use <tt>fdwait</tt> function:</p>

<pre>
int events = fdwait(fd, FDW_IN | FDW_OUT, -1);
if(events & FDW_IN) {
    ...
}
if(events & FDW_OUT) {
    ...
}
if(events & FDW_ERR) {
    ...
}
</pre>

<p>Note that error (<tt>FDW_ERR</tt>) can be returned from the function
irrespective of whether you asked for it or not.</p>

<p>The third parameter is timeout, in milliseconds. -1 means no timeout.</p>

<h3 id="channels">Channels</h3>

<p>Channels are typed pipes used for communication between coroutines. To create
a channel you have to specify what kind of values are meant to be passed
through it. The second parameter is buffer size. Setting this argument
to zero creates an unbuffered channel:</p>

<pre>
chan ch = chmake(int, 0);
</pre>

<p>To send a value to the channel use <tt>chs</tt>. Note that it is a statement,
not a function returning a value. The type specified as the second parameter
must match the type of the channel otherwise you'll get runtime exception.</p>

<pre>
chs(ch, int, 42);
</pre>

<p>To receive a value from the channel use <tt>chr</tt>. The type
specified as the second parameter must match the type of the channel otherwise
the program will abort with runtime exception.</p>

<pre>
int i = chr(ch, int);
</pre>

<p>When the sender is done with sending it can announce the fact using
<tt>chdone</tt> function. It will cause all the receivers on the channel to
receive the value specified in the third parameter indefinitely:</p>

<pre>
chdone(ch, int, -1);
</pre>

<p>To deallocate the channel use <tt>chclose</tt> function:</p>

<pre>
chclose(ch);
</pre>

<p>Note that <tt>chclose</tt> deallocates any elements remaining the channel,
however, if the element itself has a pointer to a different object, that object
won't be deallocated. In this respect <tt>chclose</tt> is similar to the
standard <tt>free</tt> function.</p>

<p>When sharing a channel between two or more coroutines you can duplicate
the channel handle. Channel is deallocated only after all its handles
are closed. For example:</p>

<pre>
void sender(chan ch) {
    chs(ch, int, 42);
    chclose(ch);
}

int main() {
    chan ch = chmake(int, 0);
    go(sender(chdup(ch)));
    int i = chr(ch, int);
    assert(i == 42);
    chclose(ch);
    return 0;
}
</pre>

<h3 id="choose">Choose statement</h3>

<p>Choose statement is equivalent to Go's <tt>select</tt> statement. It can be
used for waiting to send or receive data from multiple channels.</p>

<p>Within <tt>choose</tt> there's a list of clauses containing multiple
<tt>in</tt> and <tt>out</tt> statements and at most one <tt>otherwise</tt>
statement. Don't forget to add <tt>end</tt> statement before the closing
parenthesis.</p>

<p>Clause <tt>in</tt> causes <tt>choose</tt> to wait for a message coming
from channel <tt>ch</tt>. The clause declares variable <tt>var</tt> of type
<tt>type</tt> and stores the incoming message into it. If <tt>type</tt> doesn't
match the actual type of the channel you'll get a runtime exception.</p>

<pre>
in(ch, type, var):
</pre>

<p>Clause <tt>out</tt> causes <tt>choose</tt> to wait while value <tt>val</tt>
of type <tt>type</tt> can be sent to channel <tt>ch</tt>. Same way as with
</tt>in</tt>, if <tt>type</tt> doesn't match the actual type of channel
<tt>ch</tt> runtime exception is generated.</p>

<pre>
out(ch, type, val):
</pre>

<p>Clause <tt>otherwise</tt> is optional. It is executed only if no other
clauses can be matched immediately. Therefore, <tt>choose</tt> statement
with <tt>otherwise</tt> clause will never block.</p>

<pre>
choose {
in(ch1, int, val):
    printf("Value %d received from ch1.\n", val);
out(ch2, int, 42):
    printf("Value 42 sent to ch2.\n");
otherwise:
    printf("Neither ch1 nor ch2 can be used at the moment.\n");
end
}
</pre>

<p><tt>choose</tt> statement waits for the first available clause and executes
the code that follows it. If there are multiple clauses available one of them
is chosen at random.</p>

<p>There's no fall-through among the clauses.</p>

<h3 id="cls">Coroutine-local storage</h3>

<p>Coroutine-local storage is an advanced mechanism meant to be used in
special cases. Avoid using it if possible. In general, use it where you would
use thread-local storage in a threaded program. TLS itself cannot be used with
libmill as multiple coroutines can share the same OS thread.</p>

<p>Coroutine local data are a single pointer which can be set like this:</p>

<pre>
void *data = ...;
setcls(data);
</pre>

<p>Later on the pointer can be accessed anywhere within the coroutine or any
function invoked from it using <tt>cls</tt> function:</p>

<pre>
void *data = cls();
</pre>

<p>It can be safely assumed that before coroutine-local data are set,
<tt>cls</tt> function will return <tt>NULL</tt>.</p>

<h3 id="tcp">TCP library</h3>

<p>TCP can be accessed via standard POSIX functions. However, libmill provides
a simple convenience wrapper for the functionality.</p>

<p>To connect to a remote server, use <tt>tcpconnect</tt> function:

<pre>
tcpsock s = tcpconnect("192.168.0.111:5555");
</pre>

<p>To start listening for incoming TCP connections use <tt>tcplisten</tt>
function. To accept next connection use <tt>tcpaccept</tt>function:</p>

<pre>
tcpsock l = tcplisten("*:5555");
while(1) {
    tcpsock s = tcpaccept(l);
    ...
}
</pre>

<p>Note that asterisk (*) can be used instead of IP address to denote all local
network interfaces.</p>

<p>To send data to the connection use <tt>tcpsend</tt> function:</p>

<pre>
tcpsend(s, "ABC", 3);
</pre>

<p>To optimise the throughput <tt>tcpwrite</tt> may store the data into output
buffer and not flush it into the network immediately. To force actual sending
of the data use <tt>tcpflush</tt> function.</p>

</p>The function returns 0 in case of success and -1 in case of error:</p>

<pre>
int rc = tcpflush(s);
assert(rc == 0);
</pre>

<p>To read data from a connection use <tt>tcprecv</tt> function:</p>

<pre>
char buf[3];
ssize_t n = tcprecv(s, buf, sizeof(buf));
</pre>

</p>The function returns 0 in case of success and -1 in case of error.</p>

<p>To help with dealing with text-based protocols libmill provides
<tt>tcprecvuntil</tt> function. It is the same as <tt>tcpread</tt> except
that the reading stops when a specific character is encountered:</p>

<pre>
char buf[256];
ssize_t n = tcprecvuntil(conn, buf, sizeof(buf), '\n');
</pre>

</p>If function managed to fill the entire buffer it returns 0. If the delimiter
character was encountered in the process return value is the total amount of
characters read including the delimiter character. In case of error the function
returns -1.</p>

<p>To close a socket (both listening and connected one) use <tt>tcpclose</tt>
function:</p>

<pre>
tcpclose(s);
</pre>

<h3 id="debug">Debugging</h3>

<p>When debugging a program you may want to inspect the coroutines being
run and the channels being used. Use <tt>goredump()</tt> function to do
that.</p>

<p>It can be used in your program but also directly from the debugger. Here's
an example <tt>gdb</tt> session:</p>

<pre>
Breakpoint 1, main () at foo.c:57
57	    if(quux &lt; 0) {
(gdb) p goredump()

COROUTINE   state                  current              created
---------------------------------------------------------------
=> (000000) running                ---                  &lt;main&gt;
   (000001) yield()                foo.c:44             foo.c:49
   (000002) yield()                foo.c:44             foo.c:50
   (000003) yield()                foo.c:44             foo.c:51
   (000004) choose(2,1)            foo.c:36             foo.c:53
   (000005) choose(3,1)            foo.c:36             foo.c:54
   (000006) choose(4,1)            baz.c:128            foo.c:55

CHANNEL  msgs/max    senders/receivers      refs  done  created
---------------------------------------------------------------
(000001) 0/100       r:4,5,6                1     no    foo.c:52
(000002) 0/0         r:4                    1     no    baz.c:9
(000003) 0/0         r:5                    1     no    baz.c:9
(000004) 0/0         r:6                    1     no    baz.c:9

$2 = void
(gdb) 
</pre>

<p>Coroutine dump contains the list of coroutines, each tagged by its ID,
state, pointer to the line of code that's being executed and to the line
that created the coroutine.</p>

<p>State field gives you name of the operation being performed along with
its arguments. So, for example, when a coroutine is blocked in <tt>chr()</tt>
you'll see the ID of the channel it is trying to receive from:</p>

<pre>
COROUTINE   state                  current              created
---------------------------------------------------------------
   (000005) chr(3)                 foo.c:12             foo.c:4
</pre>

<p>Same applies when sending to a channel:</p>

<pre>
COROUTINE   state                  current              created
---------------------------------------------------------------
   (000012) chs(3)                 foo.c:17             foo.c:4
</pre>

<p>When <tt>choose</tt> statement is being executed a list of channel IDs
is provided, corresponding to the list of clauses in the <tt>choose</tt>
statement:</p>

<pre>
COROUTINE   state                  current              created
---------------------------------------------------------------
   (000005) choose(3,1)            foo.c:36             foo.c:54
</pre>

<p>Channel dump (it may be ommitted if there are no channels) reports channel
ID, number of messages buffered in the channel, maximum channel capacity,
channel's reference count, whether <tt>chdone()</tt> was already called and a
pointer to the line of code that created the channel.</p> 

<p>Additionally, if there are any receivers waiting for messages from the
channel -- whether via <tt>chr</tt> or <tt>choose</tt> -- they are reported
like this:</p>

<pre>
CHANNEL  msgs/max    senders/receivers      refs  done  created
---------------------------------------------------------------
(000001) 0/100       r:4,5,6                1     no    foo.c:52
</pre>

<p>The receivers are served in the displayed order, i.e. when a new message
is sent to the channel it will be dispatched to coroutine 4. Next one will
go to coroutine 5 and so on.</p>

<p>Similarly, waiting senders (<tt>chs</tt> or <tt>choose</tt>) are
reported like this:</p>

<pre>
CHANNEL  msgs/max    senders/receivers      refs  done  created
---------------------------------------------------------------
(000001) 100/100     s:12,15                1     no    baz.c:231
</pre>

<p>If there are no coroutines waiting to send or receive messages from the
channel the field is left empty.</p>

</body>
</html>

