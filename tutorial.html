<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>libmill</title>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>

<img src="libmill.png"/>

<p><b>Go-style concurrency in C</b></p>

<ul id='toplist'>
<li><a href="index.html">Home</a></li>
<li><a href="download.html">Download</a></li>
<li><a href="tutorial.html">Tutorial</a></li>
<li><a href="documentation.html">Documentation</a></li>
<li><a href="development.html">Development</a></li>
<li><a href="community.html">Community</a></li>
</ul>

<h2>Tutorial</h2>

<ul id="toc">
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#step1">Step 1: Setting up the stage</a></li>
  <li><a href="#step2">Step 2: The business logic</a></li>
  <li><a href="#step3">Step 3: Making it robust</a></li>
  <li><a href="#step4">Step 4: Making it parallel</a></li>
  <li><a href="#step5">Step 5: Deadlines</a></li>
  <li><a href="#step6">Step 6: Communicating among coroutines</a></li>
  <li><a href="#step7">Step 7: Multi-process server</a></li>
</ul>

<h3 id="introduction">Introduction</h3>

<p>In this tutorial you will develop a simple TCP "greet" server. The client
is meant to connect to it via telnet. After doing so, the server will ask
for their name, reply with a greeting and close the connection.</p>

<p>An interaction with our server will look like this:</p>

<pre>
$ telnet 127.0.0.1 5555
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
What's your name?
Bartholomaeus
Hello, Bartholomaeus!
Connection closed by foreign host.
</pre>

<p>In the process you will learn how to use coroutines, channels and the TCP
library.</p>

<h3 id="step1">Step 1: Setting up the stage</h3>

<p>First, include libmill's header file. Later on you will want some
functionality from the standard library, so include those headers as well:</p>
    
<pre>
#include &lt;libmill.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
</pre>

<p>Add the <tt>main</tt> function. We'll assume, that the first argument,
if present, will be the port number to be used by the server. If not specified,
we will default to 5555:</p>

<pre>
int main(int argc, char *argv[]) {
    int port = 5555;
    if(argc &gt; 1)
        port = atoi(argv[1]);

    return 0;
}
</pre>

<p>Now we can start doing the actual interesting stuff.</p>

<p>Libmill's <tt>tcplisten()</tt> function can be used to create listening
TCP socket. The socket will be used to accept new TCP connections from the
clients:</p>

<pre>
ipaddr addr = iplocal(NULL, port, 0);
tcpsock ls = tcplisten(addr);
if(!ls) {
    perror("Can't open listening socket");
    return 1;
}
</pre>

<p><tt>iplocal()</tt> function is used to convert textual representation of an
IP address to the actual address. In this case, the first argument can be used
to specify local network interface to bind to. This is an advanced functionality
and you likely won't need it. Conveniently, you can just ignore it and set the
argument to <tt>NULL</tt>. The server will then bind to all available local
network interfaces.</p>

<p>The second argument is, unsurprisingly, the port that the clients will
connect to. When testing the program keep in mind that the range of valid port
numbers is 1 to 65535 and binding to the ports from 1 to 1023 typically requires
superuser privileges.</p>

<p>If <tt>tcplisten()</tt> fails it returns NULL and sets <tt>errno</tt> to
appropriate error code. Libmill's TCP functions are in this respect very similar
to standard POSIX APIs. What it means is that we can use standard POSIX
mechanims -- <tt>perror()</tt> in this case -- to deal with errors.</p>

<p>If you run the program at this stage you'll find out that it finishes
immediately rather than pausing and waiting for a connection from the client
to arrive. That is what <tt>tcpaccept()</tt> function is for:

<pre>
tcpsock as = tcpaccept(ls, -1);
</pre>

<p>The function returns the newly established connection.</p>

<p>The second argument of the function is a deadline. We'll cover the
deadlines later on in this tutorial. For now, remember that constant -1 can
be used to mean 'no deadline' -- if there is no incoming connection
the call will block forever.</p>

<p>Finally, we want to handle many connections from the clients rather than
a single one so we put the <tt>tcpaccept()</tt> call into an infinite loop.</p>

<p>For now we'll just print a message when new connection is established
and close it immediately:</p>

<pre>
while(1) {
    tcpsock as = tcpaccept(ls, -1);
    printf("New connection!\n");
    tcpclose(as);
}
</pre>

<p>The source code for this step can be found in <tt>tutorial/step1.c</tt>.
All the following steps will be available in the same directory.</p>

<p>Build it like this:</p>

<pre>
$ gcc -o greetserver step1.c -lmill
</pre>

<p>Then run the resulting executable:</p>

<pre>
$ ./greetserver
</pre>

<p>The server now waits for a new connection. Establish one from a different
terminal using telnet and check whether it works like expected:</p>

<pre>
$ telnet 127.0.0.1 5555
</pre>

<p>To test whether error hadling works all right try to use invalid port
number:</p>

<pre>
$ ./greetserver 70000
Can't open listening socket: Invalid argument
$
</pre>

<p>Everyting seems to work as expected. Let's now move to the step 2.</p>

<h3 id="step2">Step 2: The business logic</h3>

<p>When new connection arrives, the first thing that we want to do is to send
the "What's your name?" question to the client:</p>

<pre>
tcpsend(as, "What's your name?\r\n", 19, -1);
tcpflush(as, -1);
</pre>

<p>First, note that <tt>tcpsend()</tt> works with bytes, not strings,
very much like POSIX <tt>send()</tt>. Zero is a perfectly valid byte to send
and thus we can't use it as a termination marker in the outgoing buffer.
Instead we have to specify the size of the buffer explicitly (19 bytes).</pp>

<p>Also note how the sending is done in two steps. The reason for that is that
libmill is designed for extremely high performance and thus it tries to
minimise the number of calls to the operating system. <tt>tcpsend()</tt>
function stores the data in user space and <tt>tcpflush()</tt> pushes it to the
kernel. That way, you can compose the message using many small, fast
<tt>tcpsend()</tt> calls and then flush it to the network using a single system
call.</p>

<pre>
char inbuf[256];
size_t sz = tcprecvuntil(as, inbuf, sizeof(inbuf), "\r", 1, -1);
</pre>

<p>This piece of code simply reads the reply from the client until it
encounters a carriage return character ('\r') which is used,
in combination with a newline ('\n'), by telnet to terminate individual
lines.</p>

<p>Network protocols tend use size-prefixed fields, for example integer 12
followed by "Hello, world!" string. In such cases, <tt>tcprecv()</tt> function
does a good job.</tt>

<p>Other protocols though, mostly the text-based ones, rely on delimiters to
separate the fields. In such case "Hello, world!" string would be sent first,
followed by a newline to indicate that the string ends. Here,
<tt>tcprecvuntil()</tt> function does a better job  as it allows you to specify
the character upon receiving which it will stop receiving further.</p>

<p>Finally, keep in mind that both sending and receiving TCP functions return
the number of characters sent or received.</p>

<p>Having received the reply from the client, we can now construct the greeting
and send it to the client. The analysis of this code is left as an exercise to
the reader:</p>

<pre>
inbuf[sz - 1] = 0;
char outbuf[256];
int rc = snprintf(outbuf, sizeof(outbuf), "Hello, %s!\r\n", inbuf);

tcpsend(as, outbuf, rc, -1);
tcpflush(as, -1);
</pre>

<p>Compile the program and check whether it works like expected!</p>

<h3 id="step3">Step 3: Making it robust</h3>

<p>Now that the program does what it is supposed to let's make it work in
actual real-world-like environment.</p>

<p>Specifically, we don't want the client to be able to crash the server, so we
have to handle the errors from TCP functions. </p>

<p>The functions related to sending and receiving report the errors in a bit
different way. They return the number of bytes sent or received (as already seen
in the previous step) and at the same time they set the <tt>errno</tt> to
indicate success or failure.</p>

<p>Imagine the case where we are reading data from a TCP connection. We want
4 bytes. The peer sends 4 bytes and closes the connection. <tt>tcprecv()</tt>
function returns the size of received buffer (4) but sets <tt>errno</tt> to
<tt>ECONNRESET</tt> to indicate that the connection was closed. If there's no
error <tt>errno</tt> is set to zero.<p>

<p>In our program we'll handle the errors silently, by jumping to the cleanup
code (<tt>tcpclose(as)</tt>):</p>

<pre>
while(1) {
    tcpsock as = tcpaccept(ls, -1);

    tcpsend(as, "What's your name?\r\n", 19, -1);
    if(errno != 0)
        goto cleanup;

    ...

    cleanup:
    tcpclose(as);
}
</pre>

<p>We should also handle errors from <tt>tcpaccept()</tt>. Given that in such
case there's no connection established yet, we'll just retry instead
of jumping to the cleanup code:</p>

<pre>
tcpsock as = tcpaccept(ls, -1);
if(!as)
    continue;
</pre>

<h3 id="step4">Step 4: Making it parallel</h3>

<p>At this point the client can't crash the server, but it can block it.
Do the following experiment:</p>

<ol>
    <li>Start the server.</li>
    <li>From a different terminal start a telnet session and let it hang
        without entering your name.</li>
    <li>From yet different terminal open a new telnet session.</li>
    <li>Observe that the second session hangs without even asking you for your
        name.</li>
</ol>

<p>The reason for the behaviour is that the program doesn't even start accepting
new connection until the entire dialogue with the client is finished. What we
want instead is running any number of dialogues with the clients in parallel.
And that is where coroutines kick in.</p>

<p>Coroutines are very much like threads. They are very lightweight though.
Measuring on a modern hardware you can run up to something like twenty million
libmill coroutines per second.</p>

<p>Coroutines are defined using <tt>coroutine</tt> keyword and launched using
<tt>go()</tt> construct.</p>

<p> In our case we can move the code performing the dialogue with the client
into a separate function and launch it as a coroutine:</p>

<pre>
coroutine void dialogue(tcpsock as) {
    tcpsend(as, "What's your name?\r\n", 19, -1);

    ...

    tcpclose(as);
}

int main(int argc, char *argv[]) {

    ...

    while(1) {
        tcpsock as = tcpaccept(ls, -1);
        if(!as)
            continue;
        go(dialogue(as));
    }
}
</pre>

<p>Let's compile it and try the initial experiment once again. As can be seen,
one client now cannot block another one. Great. Let's move on.</p>

<h3 id="step5">Step 5: Deadlines</h3>

<p>File descriptors can be a scarce resource. If a client connects to
greetserver and lets the dialogue hang without entering the name, one file
descriptor on the server side is, for all practical purposes, wasted.</p>

<p>To deal with the problem we are going to timeout the whole client/server
dialogue. If it takes more than 10 seconds, server will kill the connection
straight away.</p>

<p>One thing to note is that libmill uses deadlines rather than more
conventional timeouts. In other words, you specify the time instant when
you want the operation to finish rather than maximum time it should take to
run. To construct deadlines easily, libmill provides <tt>now()</tt> function.
The deadline is expressed in milliseconds so you can create a deadline
10 seconds in the future like this:</p>

<pre>
int64_t deadline = now() + 10000;
</pre>

<p>Further, you have to modify all the potentially blocking function calls in
the program to take the deadline parameter. For example:</p>

<pre>
tcpsend(as, "What's your name?\r\n", 19, deadline);
if(errno != 0)
    goto cleanup;
tcpflush(as, deadline);
if(errno != 0)
    goto cleanup;
</pre>

<p>Note that <tt>errno</tt> is set to <tt>ETIMEDOUT</tt> in case the deadline
is reached. However, we treat all the errors in the same way (by closing the
connection) and thus we don't have to do any specific provisions for the
deadline case.</p>

<h3 id="step6">Step 6: Communicating among coroutines</h3>

<p>Imagine we want to keep statistics in the greetserver: Number of overall
connections, number of those that are active at the moment and number of
those that have failed.</p>

<p>In a classic thread-based application we would keep the statistics in
global variables and synchronise access to them using mutexes.</p>

<p>With libmill, however, we are aiming at "concurrency by message passing"
and thus we are going to implement the feature in a different way.</p>

<p>We will create a new coroutine that will keep track of the statistics and
a channel that will be used by <tt>dialogue()</tt> coroutines to communicate
with it:</p>

<p><img src="tutorial1.jpeg"/></p>

<p>First, we define values that will be passed through the channel:</p>

<pre>
#define CONN_ESTABLISHED 1
#define CONN_SUCCEEDED 2
#define CONN_FAILED 3
</pre>

<p>Now we can create the channel and pass it to <tt>dialogue()</tt> coroutines:
</p>

<pre>
coroutine void dialogue(tcpsock as, chan ch) {
    ...
}

int main(int argc, char *argv[]) {

    ...

    chan ch = chmake(int, 0);

    while(1) {
        tcpsock as = tcpaccept(ls, -1);
        if(!as)
            continue;
        go(dialogue(as, ch));
    }
}
</pre>

<p>The first argument to <tt>chmake()</tt> is the type of the values that
will be passed through the channel. In our case, they are simple integers.</p>

<p>The second argument is the size of channel's buffer. Setting it to zero means
that the channel is "unbuffered" or, in other words, that the sending coroutine
will block each time until the receiving coroutine can process the message.</p>

<p>This kind of behaviour could, in theory, become a bottleneck, however,
in our case we assume that <tt>statistics()</tt> coroutine will be extremely
fast and not likely to turn into a performance bottleneck.</p>

<p>At this point we can implement the <tt>statistics()</tt> coroutine that
will run forever in a busy loop and collect the statistics from all the
<tt>dialogue()</tt> coroutines. Each time the statistics change, it will print
them to <tt>stdout</tt>:</p>

<pre>
coroutine void statistics(chan ch) {
    int connections = 0;
    int active = 0;
    int failed = 0;
    
    while(1) {
        int op = chr(ch, int);

        if(op == CONN_ESTABLISHED)
            ++connections, ++active;
        else
            --active;
        if(op == CONN_FAILED)
            ++failed;

        printf("Total number of connections: %d\n", connections);
        printf("Active connections: %d\n", active);
        printf("Failed connections: %d\n\n", failed);
    }
}

int main(int argc, char *argv[]) {

    ...

    chan ch = chmake(int, 0);
    go(statistics(ch));

    ...

}
</pre>

<p><tt>chr()</tt> function will retrieve one message from the channel or block
if there is none available. At the moment we are not sending anything to the
channel, so the coroutine will simply block forever.</p>

<p>To fix that, let's modify <tt>dialogue()</tt> coroutine to send some
messages to the channel. <tt>chs()</tt> function will be used to do that:</p>

<pre>
coroutine void dialogue(tcpsock as, chan ch) {
    chs(ch, int, CONN_ESTABLISHED);

    ...

    cleanup:
    if(errno == 0)
        chs(ch, int, CONN_SUCCEEDED);
    else
        chs(ch, int, CONN_FAILED);
    tcpclose(as);
}
</pre>

<p>Now compile the server and run it. Create a telnet session and let it
timeout. The output on the server side will look like this:</p>

<pre>
$ ./greetserver
Total number of connections: 1
Active connections: 1
Failed connections: 0

Total number of connections: 1
Active connections: 0
Failed connections: 1
</pre>

<p>The first block of text is displayed when the connection is established:
There have been 1 connection ever and 1 is active at the moment.</p>

<p>Second block shows up when the connection times out: There have been 1
connection overall, there are no active connection any longer and one connection
have failed in the past.</p>

<h3 id="step7">Step 7: Multi-process server</h3>

<p>Our new server does what it is supposed to do. With no context switching
it has performance that can never be matched by a multithreaded server. But it
has one major drawback. It runs only on one CPU core. Even if the machine has
64 cores it runs on one of them and leaves 63 cores unutilised.</p>

<p>If the server is IO-bound, as it happens to be in this tutorial, it doesn't
really matter. However, if it was CPU-bound we would face a serious problem.</p>

<p>What we are going to do in this step is to create one server process per
CPU core and distribute the incoming connections among the processes. That way,
each process can run on one CPU core, fully utilising resources of the machine.
</p>

<p>First, let's do some preparatory work. We want statistics to print out
the process ID so that we can distinguish between outputs from different
instances of the server. (And yes, it would be better to aggregate the
statistics from all instances, but that's out of scope of this tutorial and
left as an exercise to the reader.)</p>

<pre>
coroutine void statistics(chan ch) {

    ...

    printf("Process ID: %d\n", (int)getpid());
    printf("Total number of connections: %d\n", connections);
    printf("Active connections: %d\n", active);
    printf("Failed connections: %d\n\n", failed);

    ...

}
</pre>

<p>Second, we won't try to estimate the number of CPU cores on the machine
and rather let the user specify it:</p>

<pre>
int main(int argc, char *argv[]) {
    int port = 5555;
    int nproc = 1;
    if(argc > 1)
        port = atoi(argv[1]);
    if(argc > 2)
        nproc = atoi(argv[2]);
    ...
}
</pre>

<p>Now we can do the actual magic. The idea is to open the listening socket
in the first process, then to fork all the remaining processes, each inheriting
the socket. Each process can then <tt>tcpaccept()</tt> connections from
the listening socket making OS work as a simple load balancer, dispatching
connections evenly among processes.</p>

<pre>
int main(int argc, char *argv[]) {

    ...

    int i;
    for (i = 0; i < nproc - 1; ++i) {
        pid_t pid = fork();
        if(pid < 0) {
           perror("Can't create new process");
           return 1;
        }
        if(pid > 0)
            break;
    }

    ...

}
</pre>

<p>The code above should be inserted right after the <tt>tcplisten()</tt> call.
</p>

<p>One thing to note is that we fork number of processes requested by the user
short by one. The reason is that the parent process itself is going to act as
one instance of the server after if finishes the fork loop.</p>

<p>Now we can check it in practice. Let's run it on 4 CPU cores:<p>

<pre>
./greetserver 5555 4
</pre>

<p>Check the processes from a different terminal using <tt>ps</tt>:</p>

<pre>
$ ps -a
  PID TTY          TIME CMD
16406 pts/14   00:00:00 lt-greetserver
16420 pts/14   00:00:00 lt-greetserver
16421 pts/14   00:00:00 lt-greetserver
16422 pts/14   00:00:00 lt-greetserver
16424 pts/7    00:00:00 ps
</pre>

<p>Telnet to the server twice to see whether the connections are dispatched
to different instances:</p>

<pre>
Process ID: 16420
Total number of connections: 1
Active connections: 1
Failed connections: 0

Process ID: 16422
Total number of connections: 1
Active connections: 1
Failed connections: 0
</pre>

<p>Yay! Everything works as expected.</p>

<p>Enjoy your time with the library and send any questions you may have to
libmill@freelists.org</p>

</body>
</html>

