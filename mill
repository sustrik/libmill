#!/usr/bin/env ruby

#
# The initial part of this file belongs to the ribosome project.
#
# Copyright (c) 2014 Martin Sustrik  All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom
# the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

module Ribosome

    # Class Block represents a rectangular area of text.
    class Block

        attr_accessor :text, :width

        def initialize(s)
            @text = []
            @width = 0
            return if s == nil

            # Split the string into individual lines.
			start = 0
			loop do
				i = s.index("\n", start) || s.size
				@text << (i == start ? "" : s[start..i - 1])
                @width = [@width, @text.last.size].max
				start = i + 1
				break if start > s.size
			end
        end

        # Weld the supplied block to the right side of this block.
        def add_right(block)

            # Merge the blocks while taking care to add whitespace
            # where they do not align properly.
            i = 0
            for l in block.text
                if(@text[i])
                    @text[i] += (" " * (@width - @text[i].size)) + l
                else
                    @text << (" " * @width) + l
                end
                i += 1
            end

            # Adjust the overall width of the block.
            @width += block.width
            
        end

        # Weld the supplied block to the bottom side of this block.
        def add_bottom(block)
            @text += block.text
            @width = [@width, block.width].max
        end

        # Trim the whitespace from the block.
        def trim()

            # Find the boundaries of the text.
            top = -1
            bottom = -1
            left = -1
            right = -1

            i = 0
            for l in @text
                if(!l.lstrip().empty?)
                    top = i if top == -1
                    bottom = i;
                    if (left == -1)
                        left = l.size() - l.lstrip().size()
                    else
                        left = [left, l.size() - l.lstrip().size()].min
                    end
                    if (right == -1)
                        right = l.rstrip().size()
                    else
                        right = [right, l.rstrip().size()].max
                    end
                end
                i += 1
            end

            # The case of block with no text whatsoever.
            if bottom == -1
                @text = []
                @width = 0
                return
            end

            # Strip off the top and bottom whitespace.
            @text = @text[top..bottom]

            # Strip off the whitespace on the left and on the right.
            for i in 0..@text.size() - 1
                @text[i] = @text[i].rstrip()[left..right]
                @text[i] = "" if @text[i] == nil
            end

            # Adjust the overall width of the block.
            @width = (@text.max {|x,y| x.size <=> y.size} || "").size

        end

        def write(out, tabsize)
            for l in @text

                # If required, replace the initial whitespace by tabs.
                if(tabsize > 0)
                    ws = l.size - l.lstrip.size
                    l = "\t" * (ws / tabsize) +
                        " " * (ws % tabsize) + l.lstrip
                end

                # Write an individual line to the output file.
                out.write(l)
                out.write("\n")
            end
        end

    end

    # Size of a tab. If set to zero, tabs are not generated.
    @tabsize = 0

    # The output file, or, alternativly, stdout.
    @outisafile = false
    @out = $stdout

    # This is the ribosome call stack. At each level there is a list of
    # text blocks generated up to that point.
    @stack = [[]]

    # Redirects output to the specified file.
    def Ribosome.output(filename)
        close()
        @outisafile = true
        @out = File.open(filename, "w")
    end

    # Redirects output to the stdout.
    def Ribosome.stdout()
        close()
        @outisafile = false
        @out = $stdout
    end

    # Sets the size of the tab.
    def Ribosome.tabsize(size)
        @tabsize = size
    end

    # Flush the data to the currently open file and close it.
    def Ribosome.close()
        for b in @stack.last
            b.write(@out, @tabsize)
        end
        @stack = [[]]
        @out.close() if @outisafile
    end

    # Adds one . line from the DNA file.
    def Ribosome.add(line, bind)

        # If there is no previous line, add one.
        if(@stack.last.empty?)
            @stack.last << Block.new("")
        end

        # In this block we will accumulate the expanded line.
        block = @stack.last.last

        # Traverse the line and convert it into a block.
        i = 0
        while true
            j = line.index(/[@&][1-9]?\{/, i)
            j = line.size if j == nil

            # Process constant block of text.
            if (i != j)
                block.add_right(Block.new(line[i..j - 1]))
            end

            break if line.size == j

            # Process an embedded expression.
            i = j
            j += 1
            level = 0
            if (line[j] >= ?1 && line[j] <= ?9)
                level = line[j] - ?0
                j += 1
            end

            # Find corresponding }.
            par = 0;
            while true
                if(line[j] == ?{)
                    par += 1
                elsif(line[j] == ?})
                    par -= 1
                end
                break if par == 0
                j += 1
                if j >= line.size
                    raise SyntaxError.new("Unmatched {")
                end
            end

            # Expression of higher indirection levels are simply brought
            # down by one level.
            if(level > 0)
                if line [i + 1] == ?1
                    block.add_right(Block.new("@" + line[i + 2..j]))
                else
                    line[i + 1] -= 1
                    block.add_right(Block.new(line[i..j]))
                end
                i = j + 1
                next
            end

            # We are at the lowest level of embeddedness so we have to
            # evaluate the embedded expression straight away.
            expr = line[(level == 0 ? i + 2 : i + 3)..j - 1]
            @stack.push([])
            val = eval(expr, bind)
            top = @stack.pop()
            if(top.empty?)
                val = Block.new(val.to_s)
            else
                val = Block.new("")
                for b in top
                    val.add_bottom(b)
                end
            end
            val.trim if line[i] == ?@
            block.add_right(val)
            i = j + 1
        end
    end

    # Adds newline followed by one . line from the DNA file.
    def Ribosome.dot(line, bind)
        @stack.last << Block.new("")
        add(line, bind)
    end

    #  Report an error that happened when executing RNA file.
    def Ribosome.rethrow(e, rnafile, linemap)
        i = 0
        for i in 0..e.backtrace.size - 1
            l = e.backtrace[i]
            if l.start_with?(rnafile + ":")
                stop = l.index(":", rnafile.size + 1) || l.size
                num = l[rnafile.size + 1..stop - 1].to_i
                for j in 0..linemap.size - 1
                    break if linemap[j][0] == nil || linemap[j][0] > num
                end
                j -= 1
                num = num - linemap[j][0] + linemap[j][2]
                l = "#{linemap[j][1]}:#{num}#{l[stop..-1]}"
                e.backtrace[i] = l
            end
        end
        raise e
    end

end

# Escape function for @
def at()
    return "@"
end

# Escape function for &
def amp()
    return "&"
end

# Escape function for /
def slash()
    return "/"
end

################################################################################
# The code that belongs to the ribosome project ends at this point of the      #
# RNA file and so does the associated license. What follows is the code        #
# generated from the DNA file.                                                 #
################################################################################



# line 1 "gen/clexer.rl"
################################################################################
# Begin generated clexer.rb (from clexer.rl).  This (generated) file is        #
# included verbatim by mill.dna to avoid an external dependency.               #
################################################################################


# line 156 "gen/clexer.rl"



# line 14 "gen/clexer.rb"
class << self
	attr_accessor :_c_actions
	private :_c_actions, :_c_actions=
end
self._c_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4, 1, 5, 1, 6, 1, 
	7, 1, 8, 1, 9, 1, 12, 1, 
	13, 1, 14, 1, 15, 1, 16, 1, 
	17, 1, 18, 1, 19, 2, 0, 9, 
	2, 0, 10, 2, 0, 11
]

class << self
	attr_accessor :_c_key_offsets
	private :_c_key_offsets, :_c_key_offsets=
end
self._c_key_offsets = [
	0, 0, 3, 4, 5, 8, 9, 10, 
	12, 18, 20, 23, 45, 46, 47, 49, 
	53, 55, 58, 64, 71
]

class << self
	attr_accessor :_c_trans_keys
	private :_c_trans_keys, :_c_trans_keys=
end
self._c_trans_keys = [
	10, 34, 92, 10, 10, 10, 39, 92, 
	10, 10, 48, 57, 48, 57, 65, 70, 
	97, 102, 10, 42, 10, 42, 47, 10, 
	34, 35, 39, 45, 47, 48, 95, 33, 
	46, 49, 57, 58, 64, 65, 90, 91, 
	96, 97, 122, 123, 126, 10, 62, 42, 
	47, 46, 120, 48, 57, 48, 57, 46, 
	48, 57, 48, 57, 65, 70, 97, 102, 
	95, 48, 57, 65, 90, 97, 122, 0
]

class << self
	attr_accessor :_c_single_lengths
	private :_c_single_lengths, :_c_single_lengths=
end
self._c_single_lengths = [
	0, 3, 1, 1, 3, 1, 1, 0, 
	0, 2, 3, 8, 1, 1, 2, 2, 
	0, 1, 0, 1, 0
]

class << self
	attr_accessor :_c_range_lengths
	private :_c_range_lengths, :_c_range_lengths=
end
self._c_range_lengths = [
	0, 0, 0, 0, 0, 0, 0, 1, 
	3, 0, 0, 7, 0, 0, 0, 1, 
	1, 1, 3, 3, 0
]

class << self
	attr_accessor :_c_index_offsets
	private :_c_index_offsets, :_c_index_offsets=
end
self._c_index_offsets = [
	0, 0, 4, 6, 8, 12, 14, 16, 
	18, 22, 25, 29, 45, 47, 49, 52, 
	56, 58, 61, 65, 70
]

class << self
	attr_accessor :_c_trans_targs
	private :_c_trans_targs, :_c_trans_targs=
end
self._c_trans_targs = [
	1, 11, 2, 1, 1, 1, 11, 3, 
	4, 11, 5, 4, 4, 4, 11, 6, 
	16, 11, 18, 18, 18, 11, 9, 10, 
	9, 9, 10, 20, 9, 11, 1, 12, 
	4, 13, 14, 15, 19, 11, 17, 11, 
	19, 11, 19, 11, 11, 11, 3, 11, 
	11, 11, 6, 11, 7, 8, 17, 11, 
	16, 11, 7, 17, 11, 18, 18, 18, 
	11, 19, 19, 19, 19, 11, 0, 11, 
	11, 11, 11, 11, 11, 11, 11, 11, 
	11, 11, 11, 0
]

class << self
	attr_accessor :_c_trans_actions
	private :_c_trans_actions, :_c_trans_actions=
end
self._c_trans_actions = [
	1, 17, 0, 0, 1, 0, 40, 0, 
	1, 15, 0, 0, 1, 0, 43, 0, 
	0, 35, 0, 0, 0, 35, 1, 0, 
	0, 1, 0, 3, 0, 37, 0, 9, 
	0, 0, 9, 9, 0, 13, 9, 13, 
	0, 13, 0, 13, 19, 40, 0, 11, 
	23, 21, 0, 23, 0, 0, 9, 27, 
	0, 29, 0, 9, 27, 0, 0, 0, 
	31, 0, 0, 0, 0, 25, 0, 33, 
	33, 35, 35, 23, 23, 23, 27, 29, 
	27, 31, 25, 0
]

class << self
	attr_accessor :_c_to_state_actions
	private :_c_to_state_actions, :_c_to_state_actions=
end
self._c_to_state_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 5, 0, 5, 0, 0, 0, 0, 
	0, 0, 0, 0, 0
]

class << self
	attr_accessor :_c_from_state_actions
	private :_c_from_state_actions, :_c_from_state_actions=
end
self._c_from_state_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 7, 0, 0, 0, 0, 
	0, 0, 0, 0, 0
]

class << self
	attr_accessor :_c_eof_trans
	private :_c_eof_trans, :_c_eof_trans=
end
self._c_eof_trans = [
	0, 0, 0, 73, 0, 0, 73, 75, 
	75, 0, 0, 0, 78, 78, 78, 81, 
	80, 81, 82, 83, 0
]

class << self
	attr_accessor :c_start
end
self.c_start = 11;
class << self
	attr_accessor :c_error
end
self.c_error = 0;

class << self
	attr_accessor :c_en_c_comment
end
self.c_en_c_comment = 9;
class << self
	attr_accessor :c_en_main
end
self.c_en_main = 11;


# line 159 "gen/clexer.rl"

def parse(data)

    curline = 1
    data = data.unpack("c*")
    eof = data.length

    stack = [[]]

	
# line 180 "gen/clexer.rb"
begin
	p ||= 0
	pe ||= data.length
	cs = c_start
	ts = nil
	te = nil
	act = 0
end

# line 169 "gen/clexer.rl"
    
# line 192 "gen/clexer.rb"
begin
	_klen, _trans, _keys, _acts, _nacts = nil
	_goto_level = 0
	_resume = 10
	_eof_trans = 15
	_again = 20
	_test_eof = 30
	_out = 40
	while true
	_trigger_goto = false
	if _goto_level <= 0
	if p == pe
		_goto_level = _test_eof
		next
	end
	if cs == 0
		_goto_level = _out
		next
	end
	end
	if _goto_level <= _resume
	_acts = _c_from_state_actions[cs]
	_nacts = _c_actions[_acts]
	_acts += 1
	while _nacts > 0
		_nacts -= 1
		_acts += 1
		case _c_actions[_acts - 1]
			when 3 then
# line 1 "NONE"
		begin
ts = p
		end
# line 226 "gen/clexer.rb"
		end # from state action switch
	end
	if _trigger_goto
		next
	end
	_keys = _c_key_offsets[cs]
	_trans = _c_index_offsets[cs]
	_klen = _c_single_lengths[cs]
	_break_match = false
	
	begin
	  if _klen > 0
	     _lower = _keys
	     _upper = _keys + _klen - 1

	     loop do
	        break if _upper < _lower
	        _mid = _lower + ( (_upper - _lower) >> 1 )

	        if data[p].ord < _c_trans_keys[_mid]
	           _upper = _mid - 1
	        elsif data[p].ord > _c_trans_keys[_mid]
	           _lower = _mid + 1
	        else
	           _trans += (_mid - _keys)
	           _break_match = true
	           break
	        end
	     end # loop
	     break if _break_match
	     _keys += _klen
	     _trans += _klen
	  end
	  _klen = _c_range_lengths[cs]
	  if _klen > 0
	     _lower = _keys
	     _upper = _keys + (_klen << 1) - 2
	     loop do
	        break if _upper < _lower
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1)
	        if data[p].ord < _c_trans_keys[_mid]
	          _upper = _mid - 2
	        elsif data[p].ord > _c_trans_keys[_mid+1]
	          _lower = _mid + 2
	        else
	          _trans += ((_mid - _keys) >> 1)
	          _break_match = true
	          break
	        end
	     end # loop
	     break if _break_match
	     _trans += _klen
	  end
	end while false
	end
	if _goto_level <= _eof_trans
	cs = _c_trans_targs[_trans]
	if _c_trans_actions[_trans] != 0
		_acts = _c_trans_actions[_trans]
		_nacts = _c_actions[_acts]
		_acts += 1
		while _nacts > 0
			_nacts -= 1
			_acts += 1
			case _c_actions[_acts - 1]
when 0 then
# line 9 "gen/clexer.rl"
		begin
curline += 1;		end
when 1 then
# line 13 "gen/clexer.rl"
		begin
	begin
		cs = 11
		_trigger_goto = true
		_goto_level = _again
		break
	end
		end
when 4 then
# line 1 "NONE"
		begin
te = p+1
		end
when 5 then
# line 23 "gen/clexer.rl"
		begin
te = p+1
 begin 
        stack.last << [:arrow, ts, te - 1]
     end
		end
when 6 then
# line 29 "gen/clexer.rl"
		begin
te = p+1
 begin 
        token = data[ts..te-1].pack("c*")
        if token == "("
            stack << [[:lbrace, ts, ts]]
        elsif token == ")"
            last = stack.pop
            last << [:end, ts, ts]
            if last[0][0] != :lbrace
                $stderr.write "#{curline}: Mismatched braces!\n"
                exit
            end
            stack.last << [:braces, last[0][1], ts, last[1..-1]]
        elsif token == "{"
            stack << [[:lcbrace, ts, ts]]
        elsif token == "}"
            last = stack.pop
            last << [:end, ts, ts]
            if last[0][0] != :lcbrace
                $stderr.write "#{curline}: Mismatched braces!\n"
                exit
            end
            stack.last << [:cbraces, last[0][1], ts, last[1..-1]]
        elsif token == "["
            stack << [[:lsbrace, ts, ts]]
        elsif token == "]"
            last = stack.pop
            last << [:end, ts, ts]
            if last[0][0] != :lsbrace
                $stderr.write "#{curline}: Mismatched braces!\n"
                exit
            end
            stack.last << [:sbraces, last[0][1], ts, last[1..-1]]
        elsif token == ";"
            stack.last << [:semicolon, ts, te - 1]
        elsif token == ","
            stack.last << [:comma, ts, te - 1]
        elsif token == "="
            stack.last << [:eq, ts, te - 1]
        elsif token == "."
            stack.last << [:dot, ts, te - 1]
        elsif token == ":"
            stack.last << [:colon, ts, te - 1]
        else
            stack.last << [:cruft, ts, te - 1]
        end
	 end
		end
when 7 then
# line 107 "gen/clexer.rl"
		begin
te = p+1
 begin 
        stack.last << [:cruft, ts, te - 1]
     end
		end
when 8 then
# line 113 "gen/clexer.rl"
		begin
te = p+1
 begin 
        stack.last << [:cruft, ts, te - 1]
     end
		end
when 9 then
# line 118 "gen/clexer.rl"
		begin
te = p+1
		end
when 10 then
# line 121 "gen/clexer.rl"
		begin
te = p+1
 begin 
        token = data[ts..te-1].pack("c*")
        if (token.strip[0..7] == "#include")
            stack.last << [:include, ts, te - 1]
        else
            stack.last << [:cruft, ts, te - 1]
        end
     end
		end
when 11 then
# line 133 "gen/clexer.rl"
		begin
te = p+1
		end
when 12 then
# line 135 "gen/clexer.rl"
		begin
te = p+1
 begin  	begin
		cs = 9
		_trigger_goto = true
		_goto_level = _again
		break
	end
  end
		end
when 13 then
# line 29 "gen/clexer.rl"
		begin
te = p
p = p - 1; begin 
        token = data[ts..te-1].pack("c*")
        if token == "("
            stack << [[:lbrace, ts, ts]]
        elsif token == ")"
            last = stack.pop
            last << [:end, ts, ts]
            if last[0][0] != :lbrace
                $stderr.write "#{curline}: Mismatched braces!\n"
                exit
            end
            stack.last << [:braces, last[0][1], ts, last[1..-1]]
        elsif token == "{"
            stack << [[:lcbrace, ts, ts]]
        elsif token == "}"
            last = stack.pop
            last << [:end, ts, ts]
            if last[0][0] != :lcbrace
                $stderr.write "#{curline}: Mismatched braces!\n"
                exit
            end
            stack.last << [:cbraces, last[0][1], ts, last[1..-1]]
        elsif token == "["
            stack << [[:lsbrace, ts, ts]]
        elsif token == "]"
            last = stack.pop
            last << [:end, ts, ts]
            if last[0][0] != :lsbrace
                $stderr.write "#{curline}: Mismatched braces!\n"
                exit
            end
            stack.last << [:sbraces, last[0][1], ts, last[1..-1]]
        elsif token == ";"
            stack.last << [:semicolon, ts, te - 1]
        elsif token == ","
            stack.last << [:comma, ts, te - 1]
        elsif token == "="
            stack.last << [:eq, ts, te - 1]
        elsif token == "."
            stack.last << [:dot, ts, te - 1]
        elsif token == ":"
            stack.last << [:colon, ts, te - 1]
        else
            stack.last << [:cruft, ts, te - 1]
        end
	 end
		end
when 14 then
# line 78 "gen/clexer.rl"
		begin
te = p
p = p - 1; begin 
        token = data[ts..te-1].pack("c*")
        if token == "coroutine"
            stack.last << [:coroutine, ts, te - 1]
        elsif token == "out"
            stack.last << [:out, ts, te - 1]
        elsif token == "endvars"
            stack.last << [:endvars, ts, te - 1]
        elsif token == "go"
            stack.last << [:go, ts, te - 1]
        elsif token == "select"
            stack.last << [:select, ts, te - 1]
        elsif token == "case"
            stack.last << [:case, ts, te - 1]
        elsif token == "cancel"
            stack.last << [:cancel, ts, te - 1]
        elsif token == "syswait"
            stack.last << [:syswait, ts, te - 1] 
        elsif token == "return"
            stack.last << [:return, ts, te - 1]
        elsif token == "struct"
            stack.last << [:struct, ts, te - 1]
        else
            stack.last << [:identifier, ts, te - 1]
        end
	 end
		end
when 15 then
# line 139 "gen/clexer.rl"
		begin
te = p
p = p - 1; begin 
        stack.last << [:cruft, ts, te - 1]
     end
		end
when 16 then
# line 145 "gen/clexer.rl"
		begin
te = p
p = p - 1; begin 
        stack.last << [:cruft, ts, te - 1]
     end
		end
when 17 then
# line 151 "gen/clexer.rl"
		begin
te = p
p = p - 1; begin 
        stack.last << [:cruft, ts, te - 1]
     end
		end
when 18 then
# line 29 "gen/clexer.rl"
		begin
 begin p = ((te))-1; end
 begin 
        token = data[ts..te-1].pack("c*")
        if token == "("
            stack << [[:lbrace, ts, ts]]
        elsif token == ")"
            last = stack.pop
            last << [:end, ts, ts]
            if last[0][0] != :lbrace
                $stderr.write "#{curline}: Mismatched braces!\n"
                exit
            end
            stack.last << [:braces, last[0][1], ts, last[1..-1]]
        elsif token == "{"
            stack << [[:lcbrace, ts, ts]]
        elsif token == "}"
            last = stack.pop
            last << [:end, ts, ts]
            if last[0][0] != :lcbrace
                $stderr.write "#{curline}: Mismatched braces!\n"
                exit
            end
            stack.last << [:cbraces, last[0][1], ts, last[1..-1]]
        elsif token == "["
            stack << [[:lsbrace, ts, ts]]
        elsif token == "]"
            last = stack.pop
            last << [:end, ts, ts]
            if last[0][0] != :lsbrace
                $stderr.write "#{curline}: Mismatched braces!\n"
                exit
            end
            stack.last << [:sbraces, last[0][1], ts, last[1..-1]]
        elsif token == ";"
            stack.last << [:semicolon, ts, te - 1]
        elsif token == ","
            stack.last << [:comma, ts, te - 1]
        elsif token == "="
            stack.last << [:eq, ts, te - 1]
        elsif token == "."
            stack.last << [:dot, ts, te - 1]
        elsif token == ":"
            stack.last << [:colon, ts, te - 1]
        else
            stack.last << [:cruft, ts, te - 1]
        end
	 end
		end
when 19 then
# line 139 "gen/clexer.rl"
		begin
 begin p = ((te))-1; end
 begin 
        stack.last << [:cruft, ts, te - 1]
     end
		end
# line 586 "gen/clexer.rb"
			end # action switch
		end
	end
	if _trigger_goto
		next
	end
	end
	if _goto_level <= _again
	_acts = _c_to_state_actions[cs]
	_nacts = _c_actions[_acts]
	_acts += 1
	while _nacts > 0
		_nacts -= 1
		_acts += 1
		case _c_actions[_acts - 1]
when 2 then
# line 1 "NONE"
		begin
ts = nil;		end
# line 606 "gen/clexer.rb"
		end # to state action switch
	end
	if _trigger_goto
		next
	end
	if cs == 0
		_goto_level = _out
		next
	end
	p += 1
	if p != pe
		_goto_level = _resume
		next
	end
	end
	if _goto_level <= _test_eof
	if p == eof
	if _c_eof_trans[cs] > 0
		_trans = _c_eof_trans[cs] - 1;
		_goto_level = _eof_trans
		next;
	end
end
	end
	if _goto_level <= _out
		break
	end
	end
	end

# line 170 "gen/clexer.rl"

    stack.last << [:end, data.length - 1, data.length - 1]

    if stack.size != 1
        $stderr.write "Missing brace at the end of the source file.\n"
        exit
    end

    return stack[0]

end

################################################################################
# End generated clexer.rb (from clexer.rl).                                    #
################################################################################

#
# Copyright (c) 2014 Martin Sustrik  All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom
# the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

################################################################################
# Parse command line arguments.                                                #
################################################################################

if ARGV.size < 1
    $stderr.write "usage: mill [options] <input-file>\n"
    exit 1
end

$input_filename = ARGV[-1]
if $input_filename.size < 4 || ![".mh", ".mc"].include?($input_filename[-3..-1])
    $stderr.write "Only files with .mh and .mc extensions are valid mill input files.\n"
    exit 1
else
    $output_filename = $input_filename[0..-4] + "." + $input_filename[-1..-1]
end

$system = false
for opt in ARGV[0..-2]
    if opt == "--system"
        $system = true;
    else
        $stderr.write "Unknown option #{opt}\n"
        exit 1
    end
end

################################################################################
# Helper functions and debugging tools.                                        #
################################################################################

# Dump the tokens to the stdout.
def dump(text, tokens)
    for t in tokens
        puts "#{t[0]}, #{t[1]}, #{t[2]}, \"#{text[t[1]..t[2]]}\""
        if t[3] != nil
            dump(text, t[3])
        end
    end
end

# Shift positions of all tokens beyond 'start' token by 'offset' characters.
def apply_offset(tokens, start, offset)
    for t in tokens
        t[1] += offset if t[1] > start
        t[2] += offset if t[2] > start
        if t[3] != nil
            apply_offset(t[3], start, offset)
        end
    end
end

# Replace specific token in the text by a different text.
def replace(text, tokens, token, newtext)
    text[token[1]..token[2]] = newtext
    offset = newtext.size - (token[2] - token[1] + 1)
    apply_offset(tokens, token[1], offset)
end

# Replace specific characters in the text by a different text.
def replacechars(text, tokens, start, stop, newtext)
    text[start..stop] = newtext
    offset = newtext.size - (stop - start + 1)
    apply_offset(tokens, start, offset)
end

# Insert specified string at the give position in the text.
def insert(text, tokens, pos, newtext)
    text.insert(pos, newtext)
    apply_offset(tokens, pos, newtext.size)
end

# Split variable declaration into its constituent parts.
def parsedecl(text, tokens)
    i = tokens.size - 1
    loop do
        if i <= 0
            $stderr.write "Invalid declaration.\n"
            exit 1
        end
        break if tokens[i][0] != :sbraces
        i -= 1
    end
    if tokens[i][0] != :identifier
        $stderr.write "Invalid declaration.\n"
        exit 1
    end
    return {
        :type => text[tokens[0][1]..tokens[i - 1][2]],
        :name => text[tokens[i][1]..tokens[i][2]],
        :postfix => (i == tokens.size - 1 ? "" :
            text[tokens[i + 1][1]..tokens.last[2]])
    }
end

# Split variable declaration with optional initialisation.
def parsedeclinit(text, tokens)
    for i in 0..tokens.size - 1
        if tokens[i][0] == :eq
            t = parsedecl(text, tokens[0..i - 1])
            t[:init] = text[tokens[i + 1][1]..tokens.last[2]]
            return t
        end
    end
    return parsedecl(text, tokens)
end

# Split variable declaration with optional out part into its constituent parts.
def parsedeclout (text, tokens)
    if tokens[0][0] != :out
        decl = parsedecl(text, tokens)
        decl[:out] = false
    else
        decl = parsedecl(text, tokens [1..-1])
        type = decl[:type].strip
        if type[-1] != ?*
            $stderr.write "Out argument must be a pointer.\n"
            exit 1
        end
        type = type[0..-2]
        decl[:out] = true
        decl[:type] = type
    end
    return decl;
end

def renderarg(arg)

    if arg[:out]
Ribosome.dot("       @{arg[:type]} *@{arg[:name]}@{arg[:postfix]}", binding)
    else
Ribosome.dot("       @{arg[:type]} @{arg[:name]}@{arg[:postfix]}", binding)
    end
end

################################################################################
# Tokenise the input file.                                                     #
################################################################################

text = IO.read($input_filename)
tokens = parse(text)

################################################################################
# Make sure that the program won't collide with mill's internal variables.     #
# The user is not supposed to use identifiers with mill_* prefix.              #
# (Unless --system option was specified on the command line.)                  #
################################################################################

begin
    def check(text, tokens)
        for t in tokens
            if t[0] == :identifier
                name = text[t[1]..t[2]]
                if name.size >= 5 && name[0..4] == "mill_"
                    $stderr.write "Identifiers can't start with mill_ prefix.\n"
                    exit 1
                end
            end
            if t[3] != nil
                check(text, t[3])
            end
        end
    end
    if !$system
        check(text, tokens)
    end
end

################################################################################
#  Now we'll traverse the mill file and split it into different sections.      #
################################################################################

# Current position in the token array.
i = 0

# Sections array will consist of the following items
# :rawc        Section containing raw C code
# :coroutine   Coroutine declaration or definition
# :alias       Coroutine alias ("coroutine x = y")
sections = []

################################################################################
#  Split the text into coroutine definitions and interleaved chunks of raw C.  #
################################################################################

i = 0
loop do

    # Find the start of next coroutine.
    # Treat anything that precedes it as raw C code.
    cstart = i
    cstop = nil
    cotype = nil
    cotext = nil
    cotokens = nil

    loop do

        if tokens[i][0] == :end
            cstop = i
            break;
        end

        if(tokens[i][0] == :coroutine &&
              tokens [i + 1][0] == :identifier &&
              tokens[i + 2][0] == :braces &&
              (tokens[i + 3][0] == :cbraces || tokens[i + 3][0] == :semicolon))
            cstop = i
            cotype = :coroutine
            cotext = text[tokens[i][1]..tokens[i + 3][2]]
            cotokens = tokens[i..i + 3]
            i += 4
            break;
        end

        if(tokens[i][0] == :coroutine &&
              tokens [i + 1][0] == :identifier &&
              tokens[i + 2][0] == :eq &&
              tokens[i + 3][0] == :identifier &&
              tokens [i + 4][0] == :semicolon)
            cstop = i
            cotype = :alias
            cotext = text[tokens[i][1]..tokens[i + 4][2]]
            cotokens = tokens[i..i + 4]
            i += 5
            break;
        end

        i += 1;
    end

    # Chunk of raw C.
    if cstart != cstop
        sections << {
            :type => :rawc,
            :text => text[tokens[cstart][1]..tokens[cstop][1] - 1],
            :tokens => tokens[cstart..cstop - 1]
        }
        apply_offset(sections.last[:tokens], 0, -sections.last[:tokens][0][1])
    end

    # End of file.
    break if i == cstop

    # Create the coroutine section.
    sections << {
        :type => cotype,
        :text => cotext,
        :tokens => cotokens
    }
    apply_offset(sections.last[:tokens], 0, -sections.last[:tokens][0][1])

end

################################################################################
#  Process raw C code. There's nothing to do except replacing coroutines       #
#  by the corresponding C structs.                                             #
################################################################################

begin
    def expand_coroutines(text, alltokens, tokens)
        for i in 0..tokens.size - 1
            if tokens[i][0] == :coroutine
                if tokens[i + 1][0] != :identifier
                    $syserr.write "'coroutine' keyword should be followed by the coroutine name.\n"
                    exit 1
                end
                name = text[tokens[i + 1][1]..tokens[i + 1][2]]
                replace(text, alltokens, tokens[i], "struct mill_coroutine_#{name}")
                replace(text, alltokens, tokens[i + 1], "")
            end
            if tokens[i][3] != nil
                expand_coroutines(text, alltokens, tokens[i][3])
            end
        end
    end

    for s in sections
        if s[:type] == :rawc
            expand_coroutines(s[:text], s[:tokens], s[:tokens])
        end
    end
end

################################################################################
#  Process coroutine sections.                                                 #
################################################################################

for i in 0..sections.size - 1
    if sections[i][:type] == :coroutine
        text = sections[i][:text]
        tokens = sections[i][:tokens]

        # Coroutine name.
        name = text[tokens[1][1]..tokens[1][2]]

        # Coroutine argument list.
        args = []
        argtokens = tokens[2][3]
        start = 0
        for j in 0..argtokens.size - 1
            break if argtokens[j][0] == :end && j == start
            if [:comma, :end].include? argtokens[j][0]
                args << parsedeclout(text, argtokens[start..j - 1])
                start = j + 1
            end
        end

        if tokens[3][0] == :cbraces

            # Coroutine body. Split it into variables part and the executable
            # code. 'endvars' statement is the delimiter between the two.
            bodytokens = tokens[3][3]
            bodytokens.unshift [:whitespace, tokens [3][1] + 1,
                bodytokens[0][1] - 1]
            for j in 1..bodytokens.size - 1
                break if bodytokens[j][0] == :endvars
            end
            if j == bodytokens.size - 1
                j = 0
            else
                if bodytokens[j + 1][0] != :semicolon
                    $stderr.write "'endvars' must be followed by a semicolon.\n"
                    exit 1
                end
            end

            # Parse the local variables.
            vars = []
            start = 1
            for k in 1..j
                if bodytokens[k][0] == :semicolon
                    vars << parsedeclinit(text, bodytokens[start..k - 1])
                    start = k + 1
                end
            end

            # Leave only the executable code in text & tokens.
            if bodytokens[j][0] == :endvars
                j += 1
                wstoken = [:whitespace, bodytokens [j][2] + 1,
                    bodytokens[j + 1][1] - 1]
                bodytokens = bodytokens[j + 1..-1]
                bodytokens.unshift(wstoken)
            end
            text = text[bodytokens[0][1]..bodytokens[-2][2]]
            apply_offset(bodytokens, 0, -bodytokens[0][1])

            # Coroutine definition.
            sections[i] = {
                :type => :codef,
                :name => name,
                :args => args,
                :vars => vars,
                :text => text,
                :tokens => bodytokens
            }

        else

            # Coroutine declaration.
            sections[i] = {
                :type => :codecl,
                :name => name,
                :args => args
            }

        end
    end
end

################################################################################
#  Process alias sections.                                                     #
################################################################################

for i in 0..sections.size - 1
    if sections[i][:type] == :alias
        text = sections[i][:text]
        tokens = sections[i][:tokens]
        new = text[tokens[1][1]..tokens[1][2]]
        old = text[tokens[3][1]..tokens[3][2]]
        sections[i] = {
            :type => :alias,
            :old => old,
            :new => new
        }
    end
end

################################################################################
# Process the executable parts of the coroutines.                              #
################################################################################

def epilogue(lastpc)
    res = "\n"
    res += 'mill_finally:
    mill_cancel_children (cf);
    cf->mill_cfh.pc = '
    res += "#{lastpc + 1};\nmill_pc_#{lastpc + 1}:"
    res += '
    if (mill_has_children (cf))
        return 0;
    mill_emit (cf);
    cf->mill_cfh.pc = '
    res += "#{lastpc + 2};\n    return 0;\nmill_pc_#{lastpc + 2}:"
    res += '
    assert (!event);'
    res += "\n"
end

for s in sections
    if s[:type] == :codef

        # Expand references to the local variables.
        def expand_vars(text, alltokens, tokens, locals, outs)
            for i in 0..tokens.size - 1
                if tokens[i][0] == :identifier && (i == 0 ||
                      (tokens[i - 1][0] != :struct &&
                       tokens[i - 1][0] != :dot &&
                       tokens[i - 1][0] != :arrow))
                    idname = text[tokens[i][1]..tokens[i][2]]
                    if locals.include? idname
                        replace(text, alltokens, tokens[i], "(cf->#{idname})")
                    elsif outs.include? idname
                        replace(text, alltokens, tokens[i], "(&cf->#{idname})")
                    end
                elsif tokens[i][3] != nil
                    expand_vars(text, alltokens, tokens[i][3], locals, outs)
                end
            end
        end
        locals = []
        outs = []
        for a in s[:args]
            if a[:out]
                outs << a[:name]
            else
                locals << a[:name]
            end
        end
        for v in s[:vars]
            locals << v[:name]
        end
        expand_vars(s[:text], s[:tokens], s[:tokens], locals, outs)

        # Expand mill keywords.
        def expand_keywords(text, alltokens, tokens, pc)
            for i in 0..tokens.size - 1

                if tokens[i][0] == :go
                    start = i
                    i += 1
                    if tokens[i][0] != :identifier
                        $stderr.write "'go' keyword should be followed by coroutine name.\n"
                        exit 1
                    end
                    name = text[tokens[i][1]..tokens[i][2]]
                    i += 1
                    if tokens[i][0] != :braces
                        $stderr.write "Argument list missing after 'go'.\n"
                        exit 1
                    end

                    replace(text, alltokens, tokens[start], "mill_go_#{name}")
                    replace(text, alltokens, tokens[i - 1], "")
                    delim = tokens[i][3].size == 1 ? "" : ", ";
                    insert(text, alltokens, tokens[i][1] + 1, "&mill_type_#{name}, cf->mill_cfh.loop, cf#{delim}")

                elsif tokens[i][0] == :select
                    if tokens[i + 1][0] != :cbraces
                        $stderr.write "'select' should be followed by a curly brace.\n"
                        exit 1
                    end
                    pc += 1
                    replace(text, alltokens, tokens[i], "mill_select(#{pc})")
                    replacechars(text, alltokens, tokens[i + 1][1], tokens[i + 1][1], "")
                    replacechars(text, alltokens, tokens[i + 1][2], tokens[i + 1][2], "mill_endselect(#{pc})")
                    subtokens = tokens[i + 1][3]
                    if subtokens[0][0] != :case && subtokens[0][0] != :cancel
                        $stderr.write "'select' block should start with 'case' statement.\n"
                        exit 1
                    end
                    first = true
                    for j in 0..subtokens.size - 1
                        if subtokens[j][0] == :case
                            if subtokens[j + 1][0] != :identifier || subtokens[j + 2][0] != :colon
                                $stderr.write "'case' keyword should be followed by a coroutine name and a colon.\n"
                                exit 1
                            end
                            replace(text, alltokens, subtokens[j], "mill_case(#{pc},")
                            replace(text, alltokens, subtokens[j + 2], ")")
                        elsif subtokens [j][0] == :cancel
                            if subtokens[j + 1][0] != :colon
                                $stderr.write "'cancel' keyword should be followed by a colon.\n"
                                exit 1
                            end
                            replace(text, alltokens, subtokens[j], "mill_cancel(#{pc})")
                            replace(text, alltokens, subtokens[j + 1], "")
                        end
                    end

                elsif tokens[i][0] == :syswait && $system
                    if tokens[i + 1][0] != :braces
                        $stderr.write "'syswait' should be followed by argument list.\n"
                        exit 1
                    end
                    replace(text, alltokens, tokens[i], "mill_syswait")
                    pc += 1
                    insert(text, alltokens, tokens[i + 1][1] + 1, "#{pc}, ")

                elsif tokens[i][0] == :return
                    replace(text, alltokens, tokens[i], "goto mill_finally")

                # Built-in support for stdmill library.
                elsif(tokens[i][0] == :identifier &&
                        ["tcpsocket_init"].include?(text[tokens[i][1]..tokens[i][2]]) &&
                        tokens[i + 1][0] == :braces)
                    insert(text, alltokens, tokens[i + 1][2], ", cf->mill_cfh.loop")

                elsif tokens[i][3] != nil
                    pc = expand_keywords(text, alltokens, tokens[i][3], pc)
                end

            end
            return pc;
        end
        s[:lastpc] = expand_keywords(s[:text], s[:tokens], s[:tokens], 0)

        # Expand coroutine-level 'cancel' clause.
        s[:hascancel] = false
        for i in 0..s[:tokens].size - 2
            if s[:tokens][i][0] == :cancel && s[:tokens][i + 1][0] == :colon
                if s[:hascancel]
                    $stderr.write "Duplicit 'cancel' clause.\n"
                    exit 1
                end
                replace(s[:text], s[:tokens], s[:tokens][i], epilogue(s[:lastpc]))
                replace(s[:text], s[:tokens], s[:tokens][i + 1], "")
                s[:hascancel] = true
            end
        end
    end
end

################################################################################
# Generate the output file.                                                    #
################################################################################

Ribosome.output $output_filename

Ribosome.dot("/* @{Time.now}:", binding)
Ribosome.dot("   This file was generated by mill from @{$input_filename} */", binding)
Ribosome.dot("", binding)
Ribosome.dot("#include \"mill.h\"", binding)
Ribosome.dot("", binding)
for s in sections

################################################################################
# First, deal with chunks of raw C code.                                       #
# These are copied to the output file verbatim.                                #
################################################################################

    if s[:type] == :rawc
Ribosome.dot("@{s[:text]}", binding)
Ribosome.dot("", binding)
    end

################################################################################
# Coroutine declarations.                                                      #
################################################################################

    if s[:type] == :codecl
Ribosome.dot("extern const struct mill_type mill_type_@{s[:name]};", binding)
Ribosome.dot("", binding)
Ribosome.dot("int mill_handler_@{s[:name]} (void *cfptr, void *event);", binding)
Ribosome.dot("", binding)
Ribosome.dot("void mill_output_@{s[:name]} (void *cfptr);", binding)
Ribosome.dot("", binding)
Ribosome.dot("void mill_go_@{s[:name]} (", binding)
Ribosome.dot("    const struct mill_type *type,", binding)
Ribosome.dot("    struct mill_loop *loop,", binding)
Ribosome.dot("    void *parent", binding)
        for a in s[:args]
Ribosome.add(",", binding)
Ribosome.dot("    @{renderarg(a)}", binding)
        end
Ribosome.add(");", binding)
Ribosome.dot("", binding)
Ribosome.dot("void @{s[:name]} (", binding)
____separate_1576____ = true
        for a in s[:args]
if(____separate_1576____)
    ____separate_1576____ = false
else
    Ribosome.add(", ", binding)
end
Ribosome.dot("    @{renderarg(a)}", binding)
        end
Ribosome.add(");", binding)
Ribosome.dot("", binding)
    end

################################################################################
# Coroutine definitions.                                                       #
################################################################################

    if s[:type] == :codef
Ribosome.dot("struct mill_cf_@{s[:name]} {", binding)
Ribosome.dot("", binding)
Ribosome.dot("    /* Generic coframe header. */", binding)
Ribosome.dot("    struct mill_cfh mill_cfh;", binding)
        if !s[:args].empty?
Ribosome.dot("", binding)
Ribosome.dot("    /* Coroutine arguments. */", binding)
        end
        hasoutargs = false
        for a in s[:args]
Ribosome.dot("    @{a[:type]} @{a[:name]}@{a[:postfix]};", binding)
        hasoutargs = true if a[:out] == true
        end
        if !s[:vars].empty?
Ribosome.dot("", binding)
Ribosome.dot("    /* Local variables. */", binding)
        end
        for v in s[:vars]
Ribosome.dot("    @{v[:type]} @{v[:name]}@{v[:postfix]};", binding)
        end
        if hasoutargs
Ribosome.dot("", binding)
Ribosome.dot("    /* Destinations for out arguments. */", binding)
        end
        for a in s[:args]
            if a[:out]
Ribosome.dot("    @{a[:type]} *mill_out_@{a[:name]}@{a[:postfix]};", binding)
            end
        end
Ribosome.dot("};", binding)
Ribosome.dot("", binding)
Ribosome.dot("int mill_handler_@{s[:name]} (void *cfptr, void *event)", binding)
Ribosome.dot("{", binding)
Ribosome.dot("    struct mill_cf_@{s[:name]} *cf;", binding)
Ribosome.dot("", binding)
Ribosome.dot("    cf = (struct mill_cf_@{s[:name]}*) cfptr;", binding)
Ribosome.dot("", binding)
Ribosome.dot("    switch (cf->mill_cfh.pc) {", binding)
Ribosome.dot("    case 0:", binding)
Ribosome.dot("        break;", binding)
for i in 1..s[:lastpc] + 2
Ribosome.dot("    case @{i}:", binding)
Ribosome.dot("        goto mill_pc_@{i};", binding)
end
Ribosome.dot("    default:", binding)
Ribosome.dot("        assert (0);", binding)
Ribosome.dot("    }", binding)
Ribosome.dot("", binding)
if s[:hascancel]
Ribosome.dot("@{s[:text]}", binding)
else
Ribosome.dot("    @{s[:text]}", binding)
end
Ribosome.dot("", binding)
if !s[:hascancel]
Ribosome.dot("@{epilogue(s[:lastpc])}", binding)
end
Ribosome.dot("    cf->mill_cfh.pc = -1;", binding)
Ribosome.dot("    return 0;", binding)
Ribosome.dot("}", binding)
Ribosome.dot("", binding)
Ribosome.dot("void mill_output_@{s[:name]} (void *cfptr)", binding)
Ribosome.dot("{", binding)
Ribosome.dot("    struct mill_cf_@{s[:name]} *cf;", binding)
Ribosome.dot("", binding)
Ribosome.dot("    cf = (struct mill_cf_@{s[:name]}*) cfptr;    ", binding)
for a in s[:args]
    if a[:out]
Ribosome.dot("    if (cf->mill_out_@{a[:name]})", binding)
Ribosome.dot("        *cf->mill_out_@{a[:name]} = cf->@{a[:name]};", binding)
    end
end
Ribosome.dot("}", binding)
Ribosome.dot("", binding)
Ribosome.dot("const struct mill_type mill_type_@{s[:name]} = {", binding)
Ribosome.dot("    mill_type_tag,", binding)
Ribosome.dot("    mill_handler_@{s[:name]},", binding)
Ribosome.dot("    mill_output_@{s[:name]},", binding)
Ribosome.dot("    \"@{s[:name]}\"", binding)
Ribosome.dot("};", binding)
Ribosome.dot("", binding)
Ribosome.dot("void mill_go_@{s[:name]} (", binding)
Ribosome.dot("    const struct mill_type *type,", binding)
Ribosome.dot("    struct mill_loop *loop,", binding)
Ribosome.dot("    void *parent", binding)
for a in s[:args]
Ribosome.add(",", binding)
Ribosome.dot("    @{renderarg(a)}", binding)
end
Ribosome.add(")", binding)
Ribosome.dot("{", binding)
Ribosome.dot("    struct mill_cf_@{s[:name]} *cf;", binding)
Ribosome.dot("", binding)
Ribosome.dot("    cf = malloc (sizeof (struct mill_cf_@{s[:name]}));", binding)
Ribosome.dot("    assert (cf);", binding)
Ribosome.dot("    mill_coframe_init (cf, type, parent, loop);", binding)
for a in s[:args]
    if a[:out]
Ribosome.dot("    cf->mill_out_@{a[:name]} = @{a[:name]};", binding)
    else
Ribosome.dot("    cf->@{a[:name]} = @{a[:name]};", binding)
    end
end
for v in s[:vars]
    if v[:init] != nil
Ribosome.dot("    cf->@{v[:name]} = @{v[:init]};", binding)
    end
end
Ribosome.dot("    mill_handler_@{s[:name]} (&cf->mill_cfh, 0);", binding)
Ribosome.dot("}", binding)
Ribosome.dot("", binding)
Ribosome.dot("void @{s[:name]} (", binding)
____separate_1706____ = true
for a in s[:args]
if(____separate_1706____)
    ____separate_1706____ = false
else
    Ribosome.add(", ", binding)
end
Ribosome.dot("    @{renderarg(a)}", binding)
end
Ribosome.add(")", binding)
Ribosome.dot("{", binding)
Ribosome.dot("    struct mill_loop loop;", binding)
Ribosome.dot("", binding)
Ribosome.dot("    mill_loop_init (&loop);", binding)
Ribosome.dot("    mill_go_@{s[:name]} (&mill_type_@{s[:name]}, &loop, 0", binding)
for a in s[:args]
Ribosome.add(", @{a[:name]}", binding)
end
Ribosome.add(");", binding)
Ribosome.dot("    mill_loop_run (&loop);", binding)
Ribosome.dot("    mill_loop_term (&loop);", binding)
Ribosome.dot("}", binding)
Ribosome.dot("", binding)
    end

################################################################################
# Coroutine aliases.                                                           #
################################################################################

    if s[:type] == :alias
Ribosome.dot("const struct mill_type mill_type_@{s[:new]} = {", binding)
Ribosome.dot("    mill_type_tag,", binding)
Ribosome.dot("    mill_handler_@{s[:old]},", binding)
Ribosome.dot("    mill_output_@{s[:old]},", binding)
Ribosome.dot("    \"@{s[:new]}\"};", binding)
Ribosome.dot("", binding)
Ribosome.dot("#define mill_go_@{s[:new]} mill_go_@{s[:old]}", binding)
Ribosome.dot("#define @{s[:new]} @{s[:old]}", binding)
    end

end


Ribosome.close()

