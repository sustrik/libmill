#!./ribosome

#
# Copyright (c) 2014 Martin Sustrik  All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom
# the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

require "clexer"

if input == nil
    $stderr.write "Input file missing.\n"
    exit
end
if input.size < 6 || input[-5..-1] != ".mill"
    $stderr.write "The input file must be a mill file.\n"
    exit
end
base_filename = input[0..-6]

################################################################################
# Debugging tools.                                                             #
################################################################################

def dump(text, tokens)
    for t in tokens
        puts "#{t[0]}, #{t[1]}, #{t[2]}, \"#{text[t[1]..t[2]]}\""
        if t[3] != nil
            dump(text, t[3])
        end
    end
end

################################################################################
# Tokenise the input file.                                                     #
################################################################################

text = IO.read(input)
tokens = parse(text)

################################################################################
# Make sure that the program won't collide with mill's internal variables.     #
# The user is not supposed to use identifiers with mill_* prefix.              #
################################################################################

begin
    def check(text, tokens)
        for t in tokens
            if t[0] == :identifier
                name = text[t[1]..t[2]]
                if name.size >= 5 && name[0..4] == "mill_"
                    $stderr.write "Identifiers can't start with mill_ prefix.\n"
                    exit
                end
            end
            if t[3] != nil
                check(text, t[3])
            end
        end
    end
    check(text, tokens)
end

################################################################################
#  Process includes.                                                           #
################################################################################

# Current position in the token array.
i = 0

# Sections array will consist of :include, :c and :coroutine items.
sections = []

begin

    # Parse the includes section.
    for i in 0..tokens.size - 1
        break if tokens[i][0] != :include
    end
    includes_end = i == tokens.size ? text.size : tokens[i][1] 
    sections << [:includes, text[0..includes_end - 1]]

    # Make sure there are no more includes in the rest of the file.
    def no_includes(token)
        if token[0] == :include
            $stderr.write "All includes must be in the beginning of the file.\n"
            exit
        end
        if [:braces, :cbraces, :sbraces].include? token[0]
            no_includes token[3]
        end
    end
    for j in i..tokens.size - 1
        no_includes tokens[j]
    end
end

################################################################################
# Parse all coroutines.                                                        #
################################################################################

# Shift positions of all tokens beyond 'start' token by 'offset' characters.
def apply_offset(tokens, start, offset)
    for t in tokens
        t[1] += offset if t[1] > start
        t[2] += offset if t[2] > start
        if t[3] != nil
            apply_offset(t[3], start, offset)
        end
    end
end

begin

    # Make typestring from a list of tokens.
    def make_type(text, tokens)
        type = ""
        last = tokens[0][1]
        for k in 0..tokens.size - 1
            if tokens[k][0] == :coframe
                type += text[last..tokens[k][1] - 1]
                type += "struct mill_coframe_#{text[tokens[k+1][1]..tokens[k+1][2]]}"
                last = tokens[k + 1][2] + 1
            end
        end
        type += text[last..tokens[-1][2]]
        return type
    end

    loop do

        # Find the start of next coroutine.
        # Treat anything that precedes it as raw C code.
        start = i
        while ![:coroutine, :end].include? tokens[i][0]
            i += 1;
        end
        stop = i
        sections << [:c, text[tokens[start][1]..tokens[stop][1] - 1]]

        # End of file.
        break if tokens[i][0] == :end

        # Parse the coroutine itself.
        # First goes coroutine name.
        i += 1
        if tokens[i][0] != :identifier
            $stderr.write "Coroutine name missing.\n"
            exit
        end
        name = text[tokens[i][1]..tokens[i][2]]

        # Coroutine argument list.
        i += 1
        if tokens[i][0] != :braces
            $stderr.write "Coroutine argument list missing.\n"
            exit
        end
        args = []
        locals = []
        argtokens = tokens[i][3]
        start = 0
        for k in 0..argtokens.size - 1
            break if argtokens[k][0] == :end && k == start
            if [:comma, :end].include? argtokens[k][0]
                if argtokens[k - 1][0] != :identifier
                    $stderr.write "Invalid coroutine argument.\n"
                    exit
                end
                argname = text[argtokens[k - 1][1]..argtokens[k - 1][2]]
                argtype = make_type(text, argtokens[start..k - 2])
                args << {:name => argname, :type => argtype}
                locals << argname
                start = k + 1
            end
        end

        # Coroutine body.
        i += 1
        if tokens[i][0] != :cbraces
            $stderr.write "Coroutine body missing.\n"
            exit
        end
        bodytokens = tokens[i][3]
        bodytokens.unshift [:whitespace, tokens [i][1] + 1, bodytokens[0][1] - 1]

        # Split the body into variable declarations and executable part.
        vartokens = []
        for j in 0..bodytokens.size - 1
            break if bodytokens[j][0] == :end
            if bodytokens[j][0] == :endvars
                if bodytokens[j + 1][0] != :semicolon
                   $stderr.write "'endvars' must be followed by a semicolon.\n"
                   exit
                end
                wsstart = bodytokens[j + 1][2] + 1
                vartokens = bodytokens[0..j - 1]
                bodytokens = bodytokens[j + 2..-1]
                bodytokens.unshift [:whitespace, wsstart, bodytokens[0][1] - 1]
                break
            end
        end
        vartokens << [:end, bodytokens[0][1] - 1, bodytokens[0][1] - 1]

        # Local variables.
        vars = []
        start = 1
        for j in 1..vartokens.size - 1
           if vartokens[j][0] == :end
               break if start == j
               $stderr.write "Invalid tokens following variable declaration.\n"
               exit
           end
           if vartokens[j][0] == :semicolon
               if vartokens[j - 1][0] != :identifier
                   $stderr.write "Invalid variable declaration.\n"
                   exit
               end
               varname = text[vartokens[j - 1][1]..vartokens[j - 1][2]]
               vartype = make_type(text, vartokens[start..j - 2])
               vars << {:name => varname, :type => vartype}
               locals << varname
               start = j + 1
           end
        end

        # Store the executable part of the coroutine
        # along with the corresponding tokens.
        body = text[bodytokens[0][1]..bodytokens[-1][1] - 1]
        apply_offset(bodytokens, 0, -bodytokens[0][1])
         
        # Create a coroutine section.
        sections << [:coroutine, {
            :name => name,
            :args => args,
            :vars => vars,
            :locals => locals,
            :body => body,
            :tokens => bodytokens
        }]

        i += 1
    end

end

# We won't need the original source code anymore. Let's garbage-collect it!
text = nil
tokens = nil

################################################################################
# Transformations within coroutine body.                                       #
################################################################################

# Replace specific token in the text by a different text.
def replace(text, tokens, token, newtext)
    text[token[1]..token[2]] = newtext
    offset = newtext.size - (token[2] - token[1] + 1)
    apply_offset(tokens, token[1], offset)
end

# Inset specified string at the give position in the text.
def insert(text, tokens, pos, newtext)
    text.insert(pos, newtext)
    apply_offset(tokens, pos, newtext.size)
end

begin

    for s in sections
        if s[0] == :coroutine
            c = s[1]
            body = c[:body]
            tokens = c[:tokens]

            # Expand local variables.
            def expand_vars(body, alltokens, tokens, locals)
                for i in 0..tokens.size - 1
                    if tokens[i][0] == :identifier && (i == 0 || tokens[i - 1][0] != :struct)
                        idname = body[tokens[i][1]..tokens[i][2]]
                        if locals.include? idname
                            replace(body, alltokens, tokens[i], "(cf->#{idname})")
                        end
                    elsif [:braces, :cbraces, :sbraces].include? tokens[i][0]
                        expand_vars(body, alltokens, tokens[i][3], locals)
                    end
                end
            end
            expand_vars(body, tokens, tokens, c[:locals])

            # Expand mill keywords.
            def expand_keywords(body, alltokens, tokens, state)
                for i in 0..tokens.size - 1

                    if tokens[i][0] == :wait
                        state += 1
                        replace(body, alltokens, tokens[i], "mill_wait (#{state})")
                    end

                    if tokens[i][0] == :return
                        for j in i + 1..tokens.size - 1
                            break if [:semicolon, :end].include? tokens[j][0]
                        end
                        if tokens[j][0] != :semicolon
                            $stderr.write "'return' statement should be terminated by semicolon.\n"
                            exit
                        end
                        s = "mill_return ("
                        s += "0" if j = i + 1
                        replace(body, alltokens, tokens[i], s)
                        replace(body, alltokens, tokens[j], ");")
                    end

                    if tokens[i][0] == :call
                        
                        # First parse the statement.
                        tag = "0"
                        frame = "0"
                        k = i + 1;
                        if tokens[k][0] == :sbraces
                            replace(body, alltokens, tokens[k - 1], "")
                            last = 0
                            for m in 1..tokens[k][3].size - 1
                                 if [:comma, :end].include? tokens[k][3][m][0]
                                     if tokens[k][3][last][0] != :identifier || tokens[k][3][last + 1][0] != :eq
                                         $stderr.write "annotations should start with an identifier followed by '='\n"
                                         exit
                                     end
                                     nm = body[tokens[k][3][last][1]..tokens[k][3][last][2]]
                                     val = body[tokens[k][3][last + 2][1]..tokens[k][3][m - 1][2]]
                                     frame = val if nm == "frame"
                                     tag = val if nm == "tag"
                                     last = m + 1
                                 end
                            end
                            k += 1
                        end
                        if tokens[k][0] != :identifier
                            $stderr.write "'call' keyword should be followed by coroutine name.\n"
                            exit
                        end
                        k += 1
                        if tokens[k][0] != :braces
                            $stderr.write "'call' should be followed by a list of arguments.\n"
                            exit
                        end
                        k += 1
                        if tokens[k][0] != :semicolon
                            $stderr.write "'call' should be terminated by a semicolon.\n"
                            exit
                        end

                        # Expand the call statement to an actuall C call.
                        func = "mill_call_#{body[tokens[k - 2][1]..tokens[k - 2][2]]}"
                        stdargs = "#{frame}, cf->mill_cfh.loop, &cf->mill_cfh, #{tag}, "
                        replace(body, alltokens, tokens[k - 3], func);
                        replace(body, alltokens, tokens[k - 2], "")
                        insert(body, alltokens, tokens[k - 1][1] + 1, stdargs)
                    end

                    if tokens[i][0] == :cancel
                        for k in i + 1..alltokens.size - 1
                            break if tokens[k][0] == :semicolon
                        end
                        if tokens[k][0] != :semicolon
                            $stderr.write "'cancel' statement should be terminated by a semicolon.\n"
                            exit
                        end
                        replace(body, alltokens, tokens[i], "mill_cancel (")
                        replace(body, alltokens, tokens[k], ");")
                    end

                    if tokens[i][0] == :cancelall
                        state += 1
                        replace(body, alltokens, tokens[i], "mill_cancelall (#{state})")
                    end

                    if tokens[i][0] == :who
                        replace(body, alltokens, tokens[i], "((void*) event)")
                    end

                    if tokens[i][0] == :tag
                        replace(body, alltokens, tokens[i], "(event->tag)")
                    end

                    if tokens[i][0] == :err
                        replace(body, alltokens, tokens[i], "(event->err)")
                    end
 
                    if(tokens[i][0] == :identifier &&
                            ["tcpsocket_init", "tcpsocket_listen"].include?(body[tokens[i][1]..tokens[i][2]]) &&
                            tokens[i + 1][0] == :braces)
                        insert(body, alltokens, tokens[i + 1][2], ", cf->mill_cfh.loop")
                    end

                    if tokens[i][3] != nil
                        state = expand_keywords(body, alltokens, tokens[i][3], state)
                    end

                end

                return state
            end
            c[:laststate] = expand_keywords(body, tokens, tokens, 0) + 1

        end
    end

end

################################################################################
# Generate the .h file.                                                        #
################################################################################

./!output base_filename + ".h"

./* @{Time.now}:
.   This file was generated from @{input} */
.
.#include "mill.h"
.
# Includes.
.@{sections[0][1]}
.
for s in sections
    if s[0] == :coroutine
        c = s[1]
.struct mill_coframe_@{c[:name]} {
.
.    /* Generic coframe header. */
.    struct mill_cfh mill_cfh;
if !c[:args].empty?
.
.    /* Coroutine arguments. */
end
for a in c[:args]
.    @{a[:type]} @{a[:name]};
end
if !c[:vars].empty?
.
.    /* Local variables. */
end
for v in c[:vars]
.    @{v[:type]} @{v[:name]};
end
.};
.
.void *mill_call_@{c[:name]} (
.    struct mill_coframe_@{c[:name]} *cf,
.    struct mill_loop *loop,
.    struct mill_cfh *parent,
.    int tag
for a in c[:args]
.    /+,
.    @{a[:type]} @{a[:name]}
end
./+);
.
.void @{c[:name]} (
./!separate ", "
for a in c[:args]
.    @{a[:type]} @{a[:name]}
end
./+);
.
    end
end

################################################################################
# Generate the .c file.                                                        #
################################################################################

./!output base_filename + ".c"

./* @{Time.now}:
.   This file was generated from @{input} */
.
.#include "@{base_filename}.h"
.
for s in sections
    if s[0] == :c
.@{s[1]}
.
    elsif s[0] == :coroutine
        c = s[1]
.static void @{c[:name]}_handler (
.    struct mill_cfh *cfh,
.    struct mill_cfh *event)
.{
.    struct mill_coframe_@{c[:name]} *cf;
.
.    cf = mill_cont (cfh, struct mill_coframe_@{c[:name]}, mill_cfh);
.
.    /* Jump to the place where the coroutine was interrupted the last time. */
.    switch (cf->mill_cfh.state) {
.    case 0:
.        break;
for i in 1..c[:laststate]
.    case @{i}:
.        goto state@{i};
end
.    default:
.        assert (0);
.    }
.
.    @{c[:body]}
.
.mill_finally:
.    mill_cancelall (@{c[:laststate]});
.    mill_cfh_emit (&cf->mill_cfh);
.}
.
.void *mill_call_@{c[:name]} (
.    struct mill_coframe_@{c[:name]} *cf,
.    struct mill_loop *loop,
.    struct mill_cfh *parent,
.    int tag
for a in c[:args]
.    /+,
.    @{a[:type]} @{a[:name]}
end
./+)
.{
.    int flags = 0;
.
.    /* If needed, allocate the coframe for the coroutine. */
.    if (!cf) {
.        flags |= MILL_FLAG_DEALLOCATE;
.        cf = malloc (sizeof (struct mill_coframe_@{c[:name]}));
.        assert (cf);
.    }
.
.    /* Fill in the coframe. */
.    mill_cfh_init (&cf->mill_cfh, @{c[:name]}_handler,
.        parent, loop, flags, tag);
for a in c[:args]
.    cf->@{a[:name]} = @{a[:name]};
end
.
.    /* Execute the initial part of the coroutine. */
.    @{c[:name]}_handler (&cf->mill_cfh, 0);
.
.    return (void*) cf;
.}
.
.void @{c[:name]} (
./!separate ", "
for a in c[:args]
.    @{a[:type]} @{a[:name]}
end
./+)
.{
.    struct mill_loop mill_loop;
.    struct mill_coframe_@{c[:name]} mill_coframe;
.
.    /* Run a new event loop to execute the coroutine in synchronous manner. */
.    mill_loop_init (&mill_loop);
.    mill_call_@{c[:name]} (&mill_coframe, &mill_loop, 0, 0
for a in c[:args]
.    /+, @{a[:name]}
end
./+);
.    mill_loop_run (&mill_loop);
.    mill_loop_term (&mill_loop);
.}
.
    end
end

